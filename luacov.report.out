==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/block.lua
==============================================================================
****0 local getfenv = require 'busted.compatibility'.getfenv
****0 local unpack = require 'busted.compatibility'.unpack
****0 local shuffle = require 'busted.utils'.shuffle

      local function sort(elements)
****0   table.sort(elements, function(t1, t2)
****0     if t1.name and t2.name then
****0       return t1.name < t2.name
          end
****0     return t2.name ~= nil
        end)
****0   return elements
      end

      return function(busted)
    1   local block = {}
    1   local root = busted.context.get()

    1   function block.reject(descriptor, element)
  323     element.env[descriptor] = function(...)
****0       error("'" .. descriptor .. "' not supported inside current context block", 2)
          end
        end

    1   function block.rejectAll(element)
   19     local env = getfenv(element.run)
   19     block.reject('randomize', element)
  342     for descriptor, _ in pairs(busted.executors) do
  323       if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then
  304         block.reject(descriptor, element)
            end
          end
        end

        local function exec(descriptor, element)
****0     if not element.env then element.env = {} end
****0     block.rejectAll(element)
****0     local ret = { busted.safe(descriptor, element.run, element) }
****0     return unpack(ret)
        end

    1   function block.execAllOnce(descriptor, current, err)
   74     local parent = busted.context.parent(current)

   74     if parent then
   55       local success = block.execAllOnce(descriptor, parent)
   55       if not success then
****0         return success
            end
          end

   74     if not current[descriptor] then
    6       current[descriptor] = {}
          end
   74     local list = current[descriptor]
   74     if list.success ~= nil then
   68       return list.success
          end

    6     local success = true
    6     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = false
            end
          end

    6     list.success = success

    6     return success
        end

    1   function block.execAll(descriptor, current, propagate, err)
   80     local parent = busted.context.parent(current)

   80     if propagate and parent then
   55       local success, ancestor = block.execAll(descriptor, parent, propagate)
   55       if not success then
****0         return success, ancestor
            end
          end

   80     local list = current[descriptor] or {}

   80     local success = true
   80     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = nil
            end
          end
   80     return success, current
        end

    1   function block.dexecAll(descriptor, current, propagate, err)
   86     local parent = busted.context.parent(current)
   86     local list = current[descriptor] or {}

   86     local success = true
   86     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = nil
            end
          end

   86     if propagate and parent then
   55       if not block.dexecAll(descriptor, parent, propagate) then
****0         success = nil
            end
          end
   86     return success
        end

    1   function block.lazySetup(element, err)
   19     return block.execAllOnce('lazy_setup', element, err)
        end

    1   function block.lazyTeardown(element, err)
    6     if element.lazy_setup and element.lazy_setup.success ~= nil then
    6       block.dexecAll('lazy_teardown', element, nil, err)
    6       element.lazy_setup.success = nil
          end
        end

    1   function block.setup(element, err)
    6       return block.execAll('strict_setup', element, nil, err)
        end

    1   function block.teardown(element, err)
    6       return block.dexecAll('strict_teardown', element, nil, err)
        end

    1   function block.execute(descriptor, element)
    5     if not element.env then element.env = {} end

    5     local randomize = busted.randomize
    5     local randomseed = busted.randomseed
    5     element.env.randomize = function(...)
****0       randomize = (select('#', ...) == 0 or ...)
****0       if randomize then
****0         randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed
            end
          end

    5     if busted.safe(descriptor, element.run, element):success() then
    5       if busted.sort then
****0         sort(busted.context.children(element))
    5       elseif randomize then
****0         element.randomseed = randomseed
****0         shuffle(busted.context.children(element), randomseed)
            end

    5       if block.setup(element) then
    5         busted.execute(element)
            end

    5       block.lazyTeardown(element)
    5       block.teardown(element)
          end
        end

    1   return block
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/context.lua
==============================================================================
****0 local tablex = require 'pl.tablex'

      local function save()
    1   local g = {}
   43   for k,_ in next, _G, nil do
   42     g[k] = rawget(_G, k)
        end
    1   return {
    1     gmt = debug.getmetatable(_G),
    1     g = g,
    1     loaded = tablex.copy(package.loaded)
    1   }
      end

      local function restore(state)
    1   setmetatable(_G, state.gmt)
   43   for k,_ in next, _G, nil do
   42     rawset(_G, k, state.g[k])
        end
   43   for k, v in next, state.g, nil do
          -- reset globals that were set to nil during the insulation block
   42     if rawget(_G, k) == nil then
****0       rawset(_G, k, v)
          end
        end
   93   for k,_ in pairs(package.loaded) do
   92     package.loaded[k] = state.loaded[k]
        end
      end

      return function()
****0   local context = {}

****0   local data = { descriptor = 'suite', attributes = {} }
****0   local parents = {}
****0   local children = {}
****0   local stack = {}
****0   local states = {}

****0   function context.ref()
****0     local ref = {}
****0     local ctx = data

          local function unwrap(element, levels)
****0       local levels = levels or 1
****0       local parent = element
****0       for i = 1, levels do
****0         parent = ref.parent(parent)
****0         if not parent then break end
            end
****0       if not element.env then element.env = {} end
****0       setmetatable(element.env, {
              __newindex = function(self, key, value)
****0           if not parent then
****0             _G[key] = value
                else
****0             if not parent.env then parent.env = {} end
****0             parent.env[key] = value
                end
              end
            })
          end

          local function push_state(current)
   24       local state = false
   24       if current.attributes.envmode == 'insulate' then
    1         state = save()
   23       elseif current.attributes.envmode == 'unwrap' then
****0         unwrap(current)
   23       elseif current.attributes.envmode == 'expose' then
****0         unwrap(current, 2)
            end
   24       table.insert(states, state)
          end

          local function pop_state(current)
   24       local state = table.remove(states)
   24       if current.attributes.envmode == 'expose' then
****0         states[#states] = states[#states] and save()
            end
   24       if state then
    1         restore(state)
            end
          end

****0     function ref.get(key)
  426       if not key then return ctx end
****0       return ctx[key]
          end

****0     function ref.set(key, value)
****0       ctx[key] = value
          end

****0     function ref.clear()
****0       data = { descriptor = 'suite', attributes = {} }
****0       parents = {}
****0       children = {}
****0       stack = {}
****0       states = {}
****0       ctx = data
          end

****0     function ref.attach(child)
   24       if not children[ctx] then children[ctx] = {} end
   24       parents[child] = ctx
   24       table.insert(children[ctx], child)
          end

****0     function ref.children(parent)
    7       return children[parent] or {}
          end

****0     function ref.parent(child)
 1781       return parents[child]
          end

****0     function ref.push(current)
   98       if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
   98       if ctx ~= current then push_state(current) end
   98       table.insert(stack, ctx)
   98       ctx = current
          end

****0     function ref.pop()
   98       local current = ctx
   98       ctx = table.remove(stack)
   98       if ctx ~= current then pop_state(current) end
   98       if not ctx then error('Context stack empty. Cannot pop.') end
          end

****0     return ref
        end

****0   return context
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/core.lua
==============================================================================
****0 local getfenv = require 'busted.compatibility'.getfenv
****0 local setfenv = require 'busted.compatibility'.setfenv
****0 local unpack = require 'busted.compatibility'.unpack
****0 local path = require 'pl.path'
****0 local pretty = require 'pl.pretty'
****0 local system = require 'system'
****0 local throw = error

****0 local failureMt = {
        __index = {},
        __tostring = function(e) return tostring(e.message) end,
****0   __type = 'failure'
      }

****0 local failureMtNoString = {
        __index = {},
****0   __type = 'failure'
      }

****0 local pendingMt = {
        __index = {},
    4   __tostring = function(p) return p.message end,
****0   __type = 'pending'
      }

      local function errortype(obj)
    2   local mt = debug.getmetatable(obj)
    2   if mt == failureMt or mt == failureMtNoString then
****0     return 'failure'
    2   elseif mt == pendingMt then
    2     return 'pending'
        end
****0   return 'error'
      end

      local function hasToString(obj)
    2   return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
      end

      local function isCallable(obj)
    1   return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
      end

      return function()
****0   local mediator = require 'mediator'()

****0   local busted = {}
****0   busted.version = '2.2.0'

****0   local root = require 'busted.context'()
****0   busted.context = root.ref()

****0   local environment = require 'busted.environment'(busted.context)

****0   busted.api = {}
****0   busted.executors = {}
****0   local executors = {}
****0   local eattributes = {}

****0   busted.gettime = system.gettime
****0   busted.monotime = system.monotime
****0   busted.sleep = system.sleep
****0   busted.status = require 'busted.status'

****0   function busted.getTrace(element, level, msg)
          local function trimTrace(info)
****0       local index = info.traceback:find('\n%s*%[C]')
****0       info.traceback = info.traceback:sub(1, index)
****0       return info
          end
   25     level = level or  3

   25     local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
   25     local info = debug.getinfo(level, 'Sl')
   29     while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
   27           (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
    4       level = level + 1
    4       info = debug.getinfo(level, 'Sl')
          end

   25     info.traceback = debug.traceback('', level)
   25     info.message = tostring(msg)

   25     local file = busted.getFile(element)
   25     return file and file.getTrace(file.name, info) or trimTrace(info)
        end

****0   function busted.rewriteMessage(element, message, trace)
    2     local file = busted.getFile(element)
    2     local msg = hasToString(message) and tostring(message)
    2     msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
    2     msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)

    2     local hasFileLine = msg:match('^[^\n]-:%d+: .*')
    2     if not hasFileLine then
    2       local trace = trace or busted.getTrace(element, 3, message)
    2       local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
    2       msg = fileline .. msg
          end

    2     return msg
        end

****0   function busted.publish(...)
   77     return mediator:publish(...)
        end

****0   function busted.subscribe(...)
   34     return mediator:subscribe(...)
        end

****0   function busted.unsubscribe(...)
****0     return mediator:removeSubscriber(...)
        end

****0   function busted.getFile(element)
   27     local parent = busted.context.parent(element)

   52     while parent do
   52       if parent.file then
    1         local file = parent.file[1]
    1         return {
    1           name = file.name,
    1           getTrace = file.run.getTrace,
    1           rewriteMessage = file.run.rewriteMessage
    1         }
            end

   51       if parent.descriptor == 'file' then
   26         return {
   26           name = parent.name,
   26           getTrace = parent.run.getTrace,
   26           rewriteMessage = parent.run.rewriteMessage
   26         }
            end

   25       parent = busted.context.parent(parent)
          end

****0     return parent
        end

****0   function busted.fail(msg, level)
****0     local rawlevel = (type(level) ~= 'number' or level <= 0) and level
****0     local level = level or 1
****0     local _, emsg = pcall(throw, msg, rawlevel or level+2)
****0     local e = { message = emsg }
****0     setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
****0     throw(e, rawlevel or level+1)
        end

****0   function busted.pending(msg)
    2     local p = { message = msg }
    2     setmetatable(p, pendingMt)
    2     throw(p)
        end

****0   function busted.bindfenv(callable, var, value)
****0     local env = {}
****0     local f = (debug.getmetatable(callable) or {}).__call or callable
****0     setmetatable(env, { __index = getfenv(f) })
****0     env[var] = value
****0     setfenv(f, env)
        end

****0   function busted.wrap(callable)
    1     if isCallable(callable) then
            -- prioritize __call if it exists, like in files
    1       environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
          end
        end

****0   function busted.safe(descriptor, run, element)
   98     busted.context.push(element)
          local trace, message
   98     local status = 'success'

  196     local ret = { xpcall(run, function(msg)
    2       status = errortype(msg)
    2       trace = busted.getTrace(element, 3, msg)
    2       message = busted.rewriteMessage(element, msg, trace)
  198     end) }

   98     if not ret[1] then
    2       if status == 'success' then
****0         status = 'error'
****0         trace = busted.getTrace(element, 3, ret[2])
****0         message = busted.rewriteMessage(element, ret[2], trace)
    2       elseif status == 'failure' and descriptor ~= 'it' then
              -- Only 'it' blocks can generate test failures. Failures in all
              -- other blocks are errors outside the test.
****0         status = 'error'
            end
            -- Note: descriptor may be different from element.descriptor when
            -- safe_publish is used (i.e. for test start/end). The safe_publish
            -- descriptor needs to be different for 'it' blocks so that we can
            -- detect that a 'failure' in a test start/end handler is not really
            -- a test failure, but rather an error outside the test, much like a
            -- failure in a support function (i.e. before_each/after_each or
            -- setup/teardown).
    2       busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)
          end
   98     ret[1] = busted.status(status)

   98     busted.context.pop()
   98     return unpack(ret)
        end

****0   function busted.safe_publish(descriptor, channel, element, ...)
   50     local args = {...}
   50     local n = select('#', ...)
   50     if channel[2] == 'start' then
   25       element.starttick = busted.monotime()
   25       element.starttime = busted.gettime()
   25     elseif channel[2] == 'end' then
   25       element.endtime = busted.gettime()
   25       element.endtick = busted.monotime()
   25       element.duration = element.starttick and (element.endtick - element.starttick)
          end
  100     local status = busted.safe(descriptor, function()
   50       busted.publish(channel, element, unpack(args, 1, n))
  100     end, element)
   50     return status:success()
        end

****0   function busted.exportApi(key, value)
****0     busted.api[key] = value
        end

****0   function busted.export(key, value)
****0     busted.exportApi(key, value)
****0     environment.set(key, value)
        end

****0   function busted.hide(key, value)
****0     busted.api[key] = nil
****0     environment.set(key, nil)
        end

****0   function busted.register(descriptor, executor, attributes)
          local alias = nil
****0     if type(executor) == 'string' then
****0       alias = descriptor
****0       descriptor = executor
****0       executor = executors[descriptor]
****0       attributes = attributes or eattributes[descriptor]
****0       executors[alias] = executor
****0       eattributes[alias] = attributes
          else
****0       if executor ~= nil and not isCallable(executor) then
****0         attributes = executor
****0         executor = nil
            end
****0       executors[descriptor] = executor
****0       eattributes[descriptor] = attributes
          end

          local publisher = function(name, fn)
   24       if not fn and type(name) == 'function' then
****0         fn = name
****0         name = alias
   24       elseif not fn then
****0         fn = attributes and attributes.default_fn
            end

            local trace

   24       local ctx = busted.context.get()
   24       if busted.context.parent(ctx) then
   23         trace = busted.getTrace(ctx, 3, name)
            end

            local publish = function(f)
   24         busted.publish({ 'register', descriptor }, name, f, trace, attributes)
            end

   24       if fn then publish(fn) else return publish end
          end

****0     local edescriptor = alias or descriptor
****0     busted.executors[edescriptor] = publisher
****0     busted.export(edescriptor, publisher)

****0     busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
   24       local ctx = busted.context.get()
   24       local plugin = {
   24         descriptor = descriptor,
   24         attributes = attributes or {},
   24         name = name,
   24         run = fn,
   24         trace = trace,
   24         starttick = nil,
   24         endtick = nil,
   24         starttime = nil,
   24         endtime = nil,
   24         duration = nil,
            }

   24       busted.context.attach(plugin)

   24       if not ctx[descriptor] then
    7         ctx[descriptor] = { plugin }
            else
   17         ctx[descriptor][#ctx[descriptor]+1] = plugin
            end
          end)
        end

****0   function busted.execute(current)
    6     if not current then current = busted.context.get() end
   30     for _, v in pairs(busted.context.children(current)) do
   24       local executor = executors[v.descriptor]
   24       if executor and not busted.skipAll then
   48         busted.safe(v.descriptor, function() executor(v) end, v)
            end
          end
        end

****0   return busted
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/environment.lua
==============================================================================
****0 local setfenv = require 'busted.compatibility'.setfenv

      return function(context)

****0   local environment = {}

        local function getEnv(self, key)
 1705     if not self then return nil end
****0     return
 1701       self.env and self.env[key] or
 1349       getEnv(context.parent(self), key) or
 1701       _G[key]
        end

        local function setEnv(self, key, value)
****0     if not self.env then self.env = {} end
****0     self.env[key] = value
        end

        local function __index(self, key)
  356     return getEnv(context.get(), key)
        end

        local function __newindex(self, key, value)
****0     setEnv(context.get(), key, value)
        end

****0   local env = setmetatable({}, { __index=__index, __newindex=__newindex })

****0   function environment.wrap(fn)
    1     return setfenv(fn, env)
        end

****0   function environment.set(key, value)
****0     local env = context.get('env')

****0     if not env then
****0       env = {}
****0       context.set('env', env)
          end

****0     env[key] = value
        end
****0   return environment
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/execute.lua
==============================================================================
    1 local shuffle = require 'busted.utils'.shuffle
    1 local urandom = require 'busted.utils'.urandom
    1 local tablex = require 'pl.tablex'

      local function sort(elements)
****0   table.sort(elements, function(t1, t2)
****0     if t1.name and t2.name then
****0       return t1.name < t2.name
          end
****0     return t2.name ~= nil
        end)
****0   return elements
      end

      return function(busted)
    1   local block = require 'busted.block'(busted)

        local function execute(runs, options)
    1     local root = busted.context.get()
    1     local children = tablex.copy(busted.context.children(root))

          local function suite_reset()
****0       local oldctx = busted.context.get()

****0       busted.context.clear()
****0       local ctx = busted.context.get()
****0       for k, v in pairs(oldctx) do
****0         ctx[k] = v
            end

****0       for _, child in ipairs(children) do
****0         for descriptor, _ in pairs(busted.executors) do
****0           child[descriptor] = nil
              end
****0         busted.context.attach(child)
            end

****0       busted.randomseed = tonumber(options.seed) or urandom() or os.time()
          end

    2     for i = 1, runs do
    1       if i > 1 then
****0         suite_reset()
****0         root = busted.context.get()
****0         busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)
            end

    1       if options.sort then
****0         sort(busted.context.children(root))
    1       elseif options.shuffle then
****0         root.randomseed = busted.randomseed
****0         shuffle(busted.context.children(root), busted.randomseed)
            end

    1       local seed = (busted.randomize and busted.randomseed or nil)
    1       if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
    1         if block.setup(root) then
    1           busted.execute()
              end
    1         block.lazyTeardown(root)
    1         block.teardown(root)
            end
    1       busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)

    1       if busted.skipAll then
              break
            end
          end
        end

    1   return execute
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/init.lua
==============================================================================
      local function init(busted)
****0   local block = require 'busted.block'(busted)

        local file = function(file)
    1     busted.wrap(file.run)
    1     if busted.safe_publish('file', { 'file', 'start' }, file) then
    1       block.execute('file', file)
          end
    1     busted.safe_publish('file', { 'file', 'end' }, file)
        end

        local describe = function(describe)
    4     local parent = busted.context.parent(describe)
    4     if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
    4       block.execute('describe', describe)
          end
    4     busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
        end

        local it = function(element)
   19     local parent = busted.context.parent(element)
          local finally

   19     if not block.lazySetup(parent) then
            -- skip test if any setup failed
****0       return
          end

   19     if not element.env then element.env = {} end

   19     block.rejectAll(element)
   19     element.env.finally = function(fn) finally = fn end
   19     element.env.pending = busted.pending

   19     local pass, ancestor = block.execAll('before_each', parent, true)

   19     if pass then
   19       local status = busted.status('success')
   19       if busted.safe_publish('test', { 'test', 'start' }, element, parent) then
   19         status:update(busted.safe('it', element.run, element))
   19         if finally then
****0           block.reject('pending', element)
****0           status:update(busted.safe('finally', finally, element))
              end
            else
****0         status = busted.status('error')
            end
   19       busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))
          end

   19     block.dexecAll('after_each', ancestor, true)
        end

        local pending = function(element)
****0     local parent = busted.context.parent(element)
****0     local status = 'pending'
****0     if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
****0       status = 'error'
          end
****0     busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
        end

****0   busted.register('file', file, { envmode = 'insulate' })

****0   busted.register('describe', describe)
****0   busted.register('insulate', 'describe', { envmode = 'insulate' })
****0   busted.register('expose', 'describe', { envmode = 'expose' })

****0   busted.register('it', it)

****0   busted.register('pending', pending, { default_fn = function() end })

****0   busted.register('before_each', { envmode = 'unwrap' })
****0   busted.register('after_each', { envmode = 'unwrap' })

****0   busted.register('lazy_setup', { envmode = 'unwrap' })
****0   busted.register('lazy_teardown', { envmode = 'unwrap' })
****0   busted.register('strict_setup', { envmode = 'unwrap' })
****0   busted.register('strict_teardown', { envmode = 'unwrap' })

****0   busted.register('setup', 'strict_setup')
****0   busted.register('teardown', 'strict_teardown')

****0   busted.register('context', 'describe')
****0   busted.register('spec', 'it')
****0   busted.register('test', 'it')

****0   busted.hide('file')

****0   local assert = require 'luassert'
****0   local spy    = require 'luassert.spy'
****0   local mock   = require 'luassert.mock'
****0   local stub   = require 'luassert.stub'
****0   local match  = require 'luassert.match'

        require 'busted.fixtures'  -- just load into the environment, not exposing it

****0   busted.export('assert', assert)
****0   busted.export('spy', spy)
****0   busted.export('mock', mock)
****0   busted.export('stub', stub)
****0   busted.export('match', match)

****0   busted.exportApi('publish', busted.publish)
****0   busted.exportApi('subscribe', busted.subscribe)
****0   busted.exportApi('unsubscribe', busted.unsubscribe)

****0   busted.exportApi('bindfenv', busted.bindfenv)
****0   busted.exportApi('fail', busted.fail)
****0   busted.exportApi('gettime', busted.gettime)
****0   busted.exportApi('monotime', busted.monotime)
****0   busted.exportApi('sleep', busted.sleep)
****0   busted.exportApi('parent', busted.context.parent)
****0   busted.exportApi('children', busted.context.children)
****0   busted.exportApi('version', busted.version)

****0   busted.bindfenv(assert, 'error', busted.fail)
****0   busted.bindfenv(assert.is_true, 'error', busted.fail)

****0   return busted
      end

****0 return setmetatable({}, {
        __call = function(self, busted)
****0     init(busted)

****0     return setmetatable(self, {
            __index = function(self, key)
   72         return busted.api[key]
            end,

            __newindex = function(self, key, value)
****0         error('Attempt to modify busted')
            end
          })
        end
      })

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/languages/en.lua
==============================================================================
    1 local s = require('say')

    1 s:set_namespace('en')

      -- 'Pending: test.lua @ 12 \n description
    1 s:set('output.pending', 'Pending')
    1 s:set('output.failure', 'Failure')
    1 s:set('output.error', 'Error')
    1 s:set('output.success', 'Success')

    1 s:set('output.pending_plural', 'pending')
    1 s:set('output.failure_plural', 'failures')
    1 s:set('output.error_plural', 'errors')
    1 s:set('output.success_plural', 'successes')

    1 s:set('output.pending_zero', 'pending')
    1 s:set('output.failure_zero', 'failures')
    1 s:set('output.error_zero', 'errors')
    1 s:set('output.success_zero', 'successes')

    1 s:set('output.pending_single', 'pending')
    1 s:set('output.failure_single', 'failure')
    1 s:set('output.error_single', 'error')
    1 s:set('output.success_single', 'success')

    1 s:set('output.seconds', 'seconds')

    1 s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
    1 s:set('output.file_not_found', 'Cannot find file or directory: %s')

      -- definitions following are not used within the 'say' namespace
    1 return {
    1   failure_messages = {
    1     'You have %d busted specs',
    1     'Your specs are busted',
    1     'Your code is bad and you should feel bad',
    1     'Your code is in the Danger Zone',
    1     'Strange game. The only way to win is not to test',
    1     'My grandmother wrote better specs on a 3 86',
    1     'Every time there\'s a failure, drink another beer',
          'Feels bad man'
    1   },
    1   success_messages = {
    1     'Aww yeah, passing specs',
    1     'Doesn\'t matter, had specs',
    1     'Feels good, man',
    1     'Great success',
          'Tests pass, drink another beer',
    1   }
    1 }

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/luajit.lua
==============================================================================
    1 local isJit = (tostring(assert):match('builtin') ~= nil)

    1 if not isJit then
    2   return function() end
      end

      -- pre-load the ffi module, such that it becomes part of the environment
      -- and Busted will not try to GC and reload it. The ffi is not suited
      -- for that and will occasionally segfault if done so.
****0 local ffi = require "ffi"


      -- patching assumes;
      --  * first parameter to be a unique key to identify repeated calls
      --  * only a single return value

      local function patch_with_return_value(func_name)
****0   local original = ffi[func_name]
****0   local original_store = {}

        ffi[func_name] = function (primary, ...)
****0     if original_store[primary] then
****0       return original_store[primary]
          end
****0     local success, result, err = pcall(original, primary, ...)
****0     if not success then
            -- hard error was thrown
****0       error(result, 2)
          end
****0     if not result then
            -- soft error was returned
****0       return result, err
          end
          -- it worked, store and return
****0     original_store[primary] = result
****0     return result
        end
      end

      local function patch_without_return_value(func_name)
****0   local original = ffi[func_name]
****0   local original_store = {}

        ffi[func_name] = function (primary, ...)
****0     if original_store[primary] then
****0       return
          end
****0     local success, result = pcall(original, primary, ...)
****0     if not success then
            -- hard error was thrown
****0       error(result, 2)
          end
          -- store and return
****0     original_store[primary] = true
****0     return result
        end
      end

      return function()
****0     patch_without_return_value("cdef")
****0     patch_with_return_value("typeof")
****0     patch_with_return_value("metatype")
****0     patch_with_return_value("load")
        end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/files/lua.lua
==============================================================================
    1 local path = require 'pl.path'

    1 local ret = {}

      local getTrace = function(filename, info)
   25   local index = info.traceback:find('\n%s*%[C]')
   25   info.traceback = info.traceback:sub(1, index)
   25   return info
      end

      ret.match = function(busted, filename)
    1   return path.extension(filename) == '.lua'
      end

      ret.load = function(busted, filename)
    1   local file, err = loadfile(filename)
    1   if not file then
****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
        end
    1   return file, getTrace
      end

    1 return ret

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/files/moonscript.lua
==============================================================================
    1 local path = require 'pl.path'

    2 local ok, moonscript, line_tables, util = pcall(function()
    1   return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
      end)

    1 local _cache = {}

      -- find the line number of `pos` chars into fname
      local lookup_line = function(fname, pos)
****0   if not _cache[fname] then
****0     local f = io.open(fname)
****0     _cache[fname] = f:read('*a')
****0     f:close()
        end

****0   return util.pos_to_line(_cache[fname], pos)
      end

      local rewrite_linenumber = function(fname, lineno)
****0   local tbl = line_tables['@' .. fname]
****0   if fname and tbl then
****0     for i = lineno, 0 ,-1 do
****0       if tbl[i] then
****0         return lookup_line(fname, tbl[i])
            end
          end
        end

****0   return lineno
      end

      local rewrite_filename = function(filename)
        -- sometimes moonscript gives files like [string "./filename.moon"], so
        -- we'll chop it up to only get the filename.
****0   return filename:match('string "(.+)"') or filename
      end

      local rewrite_traceback = function(fname, trace)
        local rewrite_one = function(line, pattern, sub)
****0     if line == nil then return '' end

****0     local fname, lineno = line:match(pattern)

****0     if fname and lineno then
****0       fname = rewrite_filename(fname)
****0       local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
****0       if new_lineno then
****0         line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
            end
          end

****0     return line
        end

****0   local lines = {}
****0   local j = 0

****0   for line in trace:gmatch('[^\r\n]+') do
****0     j = j + 1
****0     line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
****0     line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')
****0     lines[j] = line
        end

****0   return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
      end

    1 local ret = {}

      local getTrace = function(filename, info)
****0   local index = info.traceback:find('\n%s*%[C]')
****0   info.traceback = info.traceback:sub(1, index)

****0   info.short_src = rewrite_filename(info.short_src)
****0   info.traceback = rewrite_traceback(filename, info.traceback)
****0   info.linedefined = rewrite_linenumber(filename, info.linedefined)
****0   info.currentline = rewrite_linenumber(filename, info.currentline)

****0   return info
      end

      local rewriteMessage = function(filename, message)
****0   local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
****0   if not fname then
****0     return message
        end

****0   fname = rewrite_filename(fname)
****0   line = rewrite_linenumber(fname, tonumber(line))

****0   return fname .. ':' .. tostring(line) .. ': ' .. msg
      end

      ret.match = function(busted, filename)
****0   return ok and path.extension(filename) == '.moon'
      end

      ret.load = function(busted, filename)
****0   local file, err = moonscript.loadfile(filename)
****0   if not file then
****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
        end
****0   return file, getTrace, rewriteMessage
      end

    1 return ret

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/filter_loader.lua
==============================================================================
      return function()
        local function filter(busted, options)
          local getFullName = function(name)
   19       local parent = busted.context.get()
   19       local names = { name }

   55       while parent and (parent.name or parent.descriptor) and
   55             parent.descriptor ~= 'file' do
   36         table.insert(names, 1, parent.name or parent.descriptor)
   36         parent = busted.context.parent(parent)
            end

   19       return table.concat(names, ' ')
          end

          local hasTag = function(name, tag)
****0       local found = name:find('#' .. tag)
****0       return (found ~= nil)
          end

          local filterExcludeTags = function(name)
   23       for i, tag in pairs(options.excludeTags) do
****0         if hasTag(name, tag) then
****0           return nil, false
              end
            end
   23       return nil, true
          end

          local filterTags = function(name)
   19       local fullname = getFullName(name)
   19       for i, tag in pairs(options.tags) do
****0         if hasTag(fullname, tag) then
****0           return nil, true
              end
            end
   19       return nil, (#options.tags == 0)
          end

          local filterOutNames = function(name)
   23       for _, filter in pairs(options.filterOut) do
****0         if getFullName(name):find(filter) ~= nil then
****0           return nil, false
              end
            end
   23       return nil, true
          end

    1     local excludeNames = {}
    1     if options.excludeNamesFile then
****0       for name in io.lines(options.excludeNamesFile) do
****0         table.insert(excludeNames, name)
            end
          end

          local excludeNamesFile = function(name)
****0       for _, filter in ipairs(excludeNames) do
****0         if getFullName(name) == filter then
****0           return nil, false
              end
            end
****0       return nil, true
          end

          local name = function(name)
   23       for _, candidate in pairs(options.name) do
****0         if string.find(candidate, getFullName(name), 1, true) then
****0           return nil, true
              end
            end
   23       return nil, (#options.name == 0)
          end

          local filterNames = function(name)
   19       for _, filter in pairs(options.filter) do
****0         if getFullName(name):find(filter) ~= nil then
****0           return nil, true
              end
            end
   19       return nil, (#options.filter == 0)
          end

          local printTestName = function(element, parent, status)
****0       if not (options.suppressPending and status == 'pending') then
****0         local fullname = getFullName()
****0         local trace = element.trace
****0         if trace and trace.what == 'Lua' then
****0           fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname
              end
****0         print(fullname)
            end
****0       return nil, false
          end

          local ignoreAll = function()
****0       return nil, false
          end

    1     local noop = function() end
          local stubOut = function(descriptor, name, fn, ...)
****0       if fn == noop then
****0         return nil, true
            end
****0       busted.publish({ 'register', descriptor }, name, noop, ...)
****0       return nil, false
          end

          local skipOnError = function()
****0       return nil, not busted.skipAll
          end

          local applyFilter = function(descriptors, name, fn)
   10       if options[name] and options[name] ~= '' then
   18         for _, descriptor in ipairs(descriptors) do
   13           busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
              end
            end
          end

          local applyDescFilter = function(descriptors, name, fn)
****0       if options[name] and options[name] ~= '' then
****0         for _, descriptor in ipairs(descriptors) do
****0           local f = function(...) return fn(descriptor, ...) end
****0           busted.subscribe({ 'register', descriptor }, f, { priority = 1 })
              end
            end
          end

    1     if options.list then
****0       busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })
****0       applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)
****0       applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)
****0       applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)
****0       applyDescFilter({ 'it', 'pending' }, 'list', stubOut)
          end

    1     applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
    1     applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
    1     applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
    1     applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)

          -- The following filters are applied in reverse order
    1     applyFilter({ 'it', 'pending' }            , 'filter'          , filterNames           )
    1     applyFilter({ 'describe', 'it', 'pending' }, 'name'            , name                  )
    1     applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'       , filterOutNames        )
    1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeNamesFile', excludeNamesFile      )
    1     applyFilter({ 'it', 'pending' }            , 'tags'            , filterTags            )
    1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags'     , filterExcludeTags     )
        end

****0   return filter
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/output_handler_loader.lua
==============================================================================
****0 local path = require 'pl.path'
****0 local hasMoon, moonscript = pcall(require, 'moonscript')
****0 local utils = require 'busted.utils'

      return function()
        local loadOutputHandler = function(busted, output, options)
          local handler

    1     utils.copy_interpreter_args(options.arguments)
    2     local success, err = pcall(function()
    1       if output:match('%.lua$') then
****0         handler = dofile(path.normpath(output))
    1       elseif hasMoon and output:match('%.moon$') then
****0         handler = moonscript.dofile(path.normpath(output))
            else
    1         handler = require('busted.outputHandlers.' .. output)
            end
          end)

    1     if not success and err:match("module '.-' not found:") then
****0       success, err = pcall(function() handler = require(output) end)
          end

    1     if not success then
****0       busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
****0       handler = require('busted.outputHandlers.' .. options.defaultOutput)
          end

    1     if options.enableSound then
****0       require 'busted.outputHandlers.sound'(options)
          end

    1     handler(options):subscribe(options)
        end

****0   return loadOutputHandler
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/test_file_loader.lua
==============================================================================
    1 local s = require 'say'

      return function(busted, loaders)
    1   local path = require 'pl.path'
    1   local dir = require 'pl.dir'
    1   local tablex = require 'pl.tablex'
    1   local fileLoaders = {}

    3   for _, v in pairs(loaders) do
    2     local loader = require('busted.modules.files.'..v)
    2     fileLoaders[#fileLoaders+1] = loader
        end

        local getTestFiles = function(rootFile, patterns, options)
          local fileList

    1     if path.isfile(rootFile) then
    1       fileList = { rootFile }
****0     elseif path.isdir(rootFile) then
****0       local getfiles = options.recursive and dir.getallfiles or dir.getfiles
****0       fileList = getfiles(rootFile)

****0       fileList = tablex.filter(fileList, function(filename)
****0         local basename = path.basename(filename)
****0         for _, patt in ipairs(options.excludes) do
****0           if patt ~= '' and basename:find(patt) then
****0             return nil
                end
              end
****0         for _, patt in ipairs(patterns) do
****0           if basename:find(patt) then
****0             return true
                end
              end
****0         return #patterns == 0
            end)

****0       fileList = tablex.filter(fileList, function(filename)
****0         if path.is_windows then
****0           return not filename:find('%\\%.%w+.%w+', #rootFile)
              else
****0           return not filename:find('/%.%w+.%w+', #rootFile)
              end
            end)
          else
****0       busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})
****0       fileList = {}
          end

    1     table.sort(fileList)
    1     return fileList
        end

        local getAllTestFiles = function(rootFiles, patterns, options)
    1     local fileList = {}
    2     for _, root in ipairs(rootFiles) do
    1       tablex.insertvalues(fileList, getTestFiles(root, patterns, options))
          end
    1     return fileList
        end

        -- runs a testfile, loading its tests
        local loadTestFile = function(busted, filename)
    1     for _, v in pairs(fileLoaders) do
    1       if v.match(busted, filename) then
    1         return v.load(busted, filename)
            end
          end
        end

        local loadTestFiles = function(rootFiles, patterns, options)
    1     local fileList = getAllTestFiles(rootFiles, patterns, options)

    2     for i, fileName in ipairs(fileList) do
    1       local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)

    1       if testFile then
    2         local file = setmetatable({
    1           getTrace = getTrace,
    1           rewriteMessage = rewriteMessage
    1         }, {
    1           __call = testFile
              })

    1         busted.executors.file(fileName, file)
            end
          end

    1     if #fileList == 0 then
****0       local pattern = patterns[1]
****0       if #patterns > 1 then
****0         pattern = '\n\t' .. table.concat(patterns, '\n\t')
            end
****0       busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
          end

    1     return fileList
        end

    1   return loadTestFiles, loadTestFile, getAllTestFiles
      end


==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/outputHandlers/base.lua
==============================================================================
    1 local table_concat = table.concat
    1 local table_insert = table.insert

      return function()
    1   local busted = require 'busted'
    1   local handler = {
    1     successes = {},
    1     successesCount = 0,
    1     pendings = {},
    1     pendingsCount = 0,
    1     failures = {},
    1     failuresCount = 0,
    1     errors = {},
    1     errorsCount = 0,
    1     inProgress = {}
        }

        handler.cancelOnPending = function(element, parent, status)
   59     return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
        end

        handler.subscribe = function(handler, options)
    1     require('busted.languages.en')
    1     handler.options = options

    1     if options.language ~= 'en' then
****0       require('busted.languages.' .. options.language)
          end

    1     busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
    1     busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
    1     busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
    1     busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
    1     busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
    1     busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
    1     busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
    1     busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
    1     busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
    1     busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
        end

        handler.getFullName = function(context)
   19     local parent = busted.parent(context)
   19     local names = { (context.name or context.descriptor) }

   55     while parent and (parent.name or parent.descriptor) and
   55           parent.descriptor ~= 'file' do

   36       table_insert(names, 1, parent.name or parent.descriptor)
   36       parent = busted.parent(parent)
          end

   19     return table_concat(names, ' ')
        end

        handler.format = function(element, parent, message, debug, isError)
          local function copyElement(e)
   19       local copy = {}
  228       for k,v in next, e do
  209         if type(v) ~= 'function' and k ~= 'env' then
  171           copy[k] = v
              end
            end
   19       return copy
          end

   19     local formatted = {
   19       trace = debug or element.trace,
   19       element = copyElement(element),
   19       name = handler.getFullName(element),
   19       message = message,
   19       randomseed = parent and parent.randomseed,
   19       isError = isError
          }
   19     formatted.element.trace = element.trace or debug

   19     return formatted
        end

        handler.getDuration = function()
    1     if not handler.endTick or not handler.startTick then
****0       return 0
          end

    1     return handler.endTick - handler.startTick
        end

        handler.baseSuiteStart = function(suite)
    1     handler.startTick = suite.starttick
    1     handler.startTime = suite.starttime
    1     return nil, true
        end

        handler.baseSuiteReset = function()
****0     handler.successes = {}
****0     handler.successesCount = 0
****0     handler.pendings = {}
****0     handler.pendingsCount = 0
****0     handler.failures = {}
****0     handler.failuresCount = 0
****0     handler.errors = {}
****0     handler.errorsCount = 0
****0     handler.inProgress = {}

****0     return nil, true
        end

        handler.baseSuiteEnd = function(suite)
    1     handler.endTick = suite.endtick
    1     handler.endTime = suite.endtime
    1     return nil, true
        end

        handler.baseTestStart = function(element, parent)
   19     handler.inProgress[tostring(element)] = {}
   19     return nil, true
        end

        handler.baseTestEnd = function(element, parent, status, debug)
          local insertTable

   19     if status == 'success' then
   17       insertTable = handler.successes
   17       handler.successesCount = handler.successesCount + 1
    2     elseif status == 'pending' then
    2       insertTable = handler.pendings
    2       handler.pendingsCount = handler.pendingsCount + 1
****0     elseif status == 'failure' then
            -- failure already saved in failure handler
****0       handler.failuresCount = handler.failuresCount + 1
****0       return nil, true
****0     elseif status == 'error' then
            -- error count already incremented and saved in error handler
****0       return nil, true
          end

   19     local formatted = handler.format(element, parent, element.message, debug)

   19     local id = tostring(element)
   19     if handler.inProgress[id] then
   23       for k, v in pairs(handler.inProgress[id]) do
    4         formatted[k] = v
            end

   19       handler.inProgress[id] = nil
          end

   19     table_insert(insertTable, formatted)

   19     return nil, true
        end

        handler.basePending = function(element, parent, message, debug)
    2     local id = tostring(element)
    2     handler.inProgress[id].message = message
    2     handler.inProgress[id].trace = debug
    2     return nil, true
        end

        handler.baseTestFailure = function(element, parent, message, debug)
****0     table_insert(handler.failures, handler.format(element, parent, message, debug))
****0     return nil, true
        end

        handler.baseTestError = function(element, parent, message, debug)
****0     handler.errorsCount = handler.errorsCount + 1
****0     table_insert(handler.errors, handler.format(element, parent, message, debug, true))
****0     return nil, true
        end

        handler.baseError = function(element, parent, message, debug)
****0     if element.descriptor ~= 'it' then
****0       handler.errorsCount = handler.errorsCount + 1
****0       table_insert(handler.errors, handler.format(element, parent, message, debug, true))
          end

****0     return nil, true
        end

    1   return handler
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/outputHandlers/plainTerminal.lua
==============================================================================
    1 local s = require 'say'
    1 local pretty = require 'pl.pretty'
    1 local io = io
    1 local type = type
    1 local string_format = string.format
    1 local string_gsub = string.gsub
    1 local io_write = io.write
    1 local io_flush = io.flush
    1 local pairs = pairs

      return function(options)
    1   local busted = require 'busted'
    1   local handler = require 'busted.outputHandlers.base'()

    1   local successDot =  '+'
    1   local failureDot =  '-'
    1   local errorDot =  '*'
    1   local pendingDot = '.'

        local pendingDescription = function(pending)
    2     local name = pending.name

    2     local string = s('output.pending') .. ' -> ' ..
    2       pending.trace.short_src .. ' @ ' ..
    2       pending.trace.currentline  ..
    2       '\n' .. name

    2     if type(pending.message) == 'string' then
    2       string = string .. '\n' .. pending.message
****0     elseif pending.message ~= nil then
****0       string = string .. '\n' .. pretty.write(pending.message)
          end

    2     return string
        end

        local failureMessage = function(failure)
****0     local string = failure.randomseed and ('Random seed: ' .. failure.randomseed .. '\n') or ''
****0     if type(failure.message) == 'string' then
****0       string = string .. failure.message
****0     elseif failure.message == nil then
****0       string = string .. 'Nil error'
          else
****0       string = string .. pretty.write(failure.message)
          end

****0     return string
        end

        local failureDescription = function(failure, isError)
****0     local string = s('output.failure') .. ' -> '
****0     if isError then
****0       string = s('output.error') .. ' -> '
          end

****0     if not failure.element.trace or not failure.element.trace.short_src then
****0       string = string ..
****0         failureMessage(failure) .. '\n' ..
              failure.name
          else
****0       string = string ..
****0         failure.element.trace.short_src .. ' @ ' ..
****0         failure.element.trace.currentline .. '\n' ..
****0         failure.name .. '\n' ..
****0         failureMessage(failure)
          end

****0     if options.verbose and failure.trace and failure.trace.traceback then
****0       string = string .. '\n' .. failure.trace.traceback
          end

****0     return string
        end

        local statusString = function()
    1     local successString = s('output.success_plural')
    1     local failureString = s('output.failure_plural')
    1     local pendingString = s('output.pending_plural')
    1     local errorString = s('output.error_plural')

    1     local sec = handler.getDuration()
    1     local successes = handler.successesCount
    1     local pendings = handler.pendingsCount
    1     local failures = handler.failuresCount
    1     local errors = handler.errorsCount

    1     if successes == 0 then
****0       successString = s('output.success_zero')
    1     elseif successes == 1 then
****0       successString = s('output.success_single')
          end

    1     if failures == 0 then
    1       failureString = s('output.failure_zero')
****0     elseif failures == 1 then
****0       failureString = s('output.failure_single')
          end

    1     if pendings == 0 then
****0       pendingString = s('output.pending_zero')
    1     elseif pendings == 1 then
****0       pendingString = s('output.pending_single')
          end

    1     if errors == 0 then
    1       errorString = s('output.error_zero')
****0     elseif errors == 1 then
****0       errorString = s('output.error_single')
          end

    1     local formattedTime = string_gsub(string_format('%.6f', sec), '([0-9])0+$', '%1')

    1     return successes .. ' ' .. successString .. ' / ' ..
    1       failures .. ' ' .. failureString .. ' / ' ..
    1       errors .. ' ' .. errorString .. ' / ' ..
    1       pendings .. ' ' .. pendingString .. ' : ' ..
    1       formattedTime .. ' ' .. s('output.seconds')
        end

        handler.testEnd = function(element, parent, status, debug)
   19     if not options.deferPrint then
   19       local string = successDot

   19       if status == 'pending' then
    2         string = pendingDot
   17       elseif status == 'failure' then
****0         string = failureDot
   17       elseif status == 'error' then
****0         string = errorDot
            end

   19       io_write(string)
   19       io_flush()
          end

   19     return nil, true
        end

        handler.suiteStart = function(suite, count, total)
    1     local runString = (total > 1 and '\nRepeating all tests (run %u of %u) . . .\n\n' or '')
    1     io_write(string_format(runString, count, total))
    1     io_flush()

    1     return nil, true
        end

        handler.suiteEnd = function()
    1     io_write('\n')
    1     io_write(statusString()..'\n')

    3     for i, pending in pairs(handler.pendings) do
    2       io_write('\n')
    2       io_write(pendingDescription(pending)..'\n')
          end

    1     for i, err in pairs(handler.failures) do
****0       io_write('\n')
****0       io_write(failureDescription(err)..'\n')
          end

    1     for i, err in pairs(handler.errors) do
****0       io_write('\n')
****0       io_write(failureDescription(err, true)..'\n')
          end

    1     return nil, true
        end

        handler.error = function(element, parent, message, debug)
****0     io_write(errorDot)
****0     io_flush()

****0     return nil, true
        end

    1   busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
    1   busted.subscribe({ 'suite', 'start' }, handler.suiteStart)
    1   busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
    1   busted.subscribe({ 'error', 'file' }, handler.error)
    1   busted.subscribe({ 'failure', 'file' }, handler.error)
    1   busted.subscribe({ 'error', 'describe' }, handler.error)
    1   busted.subscribe({ 'failure', 'describe' }, handler.error)

    1   return handler
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/runner.lua
==============================================================================
      -- Busted command-line runner

****0 local path = require 'pl.path'
****0 local tablex = require 'pl.tablex'
****0 local term = require 'term'
****0 local utils = require 'busted.utils'
****0 local exit = require 'busted.compatibility'.exit
****0 local loadstring = require 'busted.compatibility'.loadstring
****0 local loaded = false

      return function(options)
****0   if loaded then return function() end else loaded = true end

****0   local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)
****0   options = tablex.update(require 'busted.options', options or {})
****0   options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')

****0   local busted = require 'busted.core'()

****0   local cli = require 'busted.modules.cli'(options)
****0   local filterLoader = require 'busted.modules.filter_loader'()
****0   local helperLoader = require 'busted.modules.helper_loader'()
****0   local outputHandlerLoader = require 'busted.modules.output_handler_loader'()

****0   local luacov = require 'busted.modules.luacov'()

****0   require 'busted'(busted)

****0   local level = 2
****0   local info = debug.getinfo(level, 'Sf')
****0   local source = info.source
****0   local fileName = source:sub(1,1) == '@' and source:sub(2) or nil
****0   local forceExit = fileName == nil

        -- Parse the cli arguments
****0   local appName = path.basename(fileName or 'busted')
****0   cli:set_name(appName)
****0   local cliArgs, err = cli:parse(arg)
****0   if not cliArgs then
****0     io.stderr:write(err .. '\n')
****0     exit(1, forceExit)
        end

****0   if cliArgs.version then
          -- Return early if asked for the version
****0     print(busted.version)
****0     exit(0, forceExit)
        end

        -- Load current working directory
****0   local _, err = path.chdir(path.normpath(cliArgs.directory))
****0   if err then
****0     io.stderr:write(appName .. ': error: ' .. err .. '\n')
****0     exit(1, forceExit)
        end

        -- If coverage arg is passed in, load LuaCovsupport
****0   if cliArgs.coverage then
****0     local ok, err = luacov(cliArgs['coverage-config-file'])
    1     if not ok then
****0       io.stderr:write(appName .. ': error: ' .. err .. '\n')
****0       exit(1, forceExit)
          end
        end

        -- If auto-insulate is disabled, re-register file without insulation
    1   if not cliArgs['auto-insulate'] then
****0     busted.register('file', 'file', {})
        end

        -- If lazy is enabled, make lazy setup/teardown the default
    1   if cliArgs.lazy then
****0     busted.register('setup', 'lazy_setup')
****0     busted.register('teardown', 'lazy_teardown')
        end

        -- Add additional package paths based on lpath and cpath cliArgs
    1   if #cliArgs.lpath > 0 then
    1     package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
        end

    1   if #cliArgs.cpath > 0 then
    1     package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
        end

        -- Load and execute commands given on the command-line
    1   if cliArgs.e then
    1     for k,v in ipairs(cliArgs.e) do
****0       loadstring(v)()
          end
        end

        -- watch for test errors and failures
    1   local failures = 0
    1   local errors = 0
    1   local quitOnError = not cliArgs['keep-going']

    2   busted.subscribe({ 'error', 'output' }, function(element, parent, message)
****0     io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
****0     return nil, true
        end)

    2   busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
****0     io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
****0     return nil, true
        end)

    2   busted.subscribe({ 'error' }, function(element, parent, message)
****0     errors = errors + 1
****0     busted.skipAll = quitOnError
****0     return nil, true
        end)

    2   busted.subscribe({ 'failure' }, function(element, parent, message)
****0     if element.descriptor == 'it' then
****0       failures = failures + 1
          else
****0       errors = errors + 1
          end
****0     busted.skipAll = quitOnError
****0     return nil, true
        end)

        -- Set up randomization options
    1   busted.sort = cliArgs['sort-tests']
    1   busted.randomize = cliArgs['shuffle-tests']
    1   busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()

        -- Set up output handler to listen to events
    2   outputHandlerLoader(busted, cliArgs.output, {
    1     defaultOutput = options.output,
    1     enableSound = cliArgs['enable-sound'],
    1     verbose = cliArgs.verbose,
    1     suppressPending = cliArgs['suppress-pending'],
    1     language = cliArgs.lang,
    1     deferPrint = cliArgs['defer-print'],
    1     arguments = cliArgs.Xoutput,
        })

        -- Pre-load the LuaJIT 'ffi' module if applicable
    1   require 'busted.luajit'()

        -- Set up helper script, must succeed to even start tests
    1   if cliArgs.helper and cliArgs.helper ~= '' then
****0     local ok, err = helperLoader(busted, cliArgs.helper, {
            verbose = cliArgs.verbose,
            language = cliArgs.lang,
****0       arguments = cliArgs.Xhelper
          })
****0     if not ok then
****0       io.stderr:write(appName .. ': failed running the specified helper (' ..
****0                       cliArgs.helper .. '), error: ' .. err .. '\n')
****0       exit(1, forceExit)
          end
        end

        local getFullName = function(name)
****0     local parent = busted.context.get()
****0     local names = { name }

****0     while parent and (parent.name or parent.descriptor) and
****0       parent.descriptor ~= 'file' do
****0       table.insert(names, 1, parent.name or parent.descriptor)
****0       parent = busted.context.parent(parent)
          end

****0     return table.concat(names, ' ')
        end

    1   if cliArgs['log-success'] then
****0     local logFile = assert(io.open(cliArgs['log-success'], 'a'))
****0     busted.subscribe({ 'test', 'end' }, function (test, parent, status)
****0       if status == "success" then
****0         logFile:write(getFullName() .. "\n")
            end
          end)
        end

        -- Load tag and test filters
    2   filterLoader(busted, {
    1     tags = cliArgs.tags,
    1     excludeTags = cliArgs['exclude-tags'],
    1     filter = cliArgs.filter,
    1     name = cliArgs.name,
    1     filterOut = cliArgs['filter-out'],
    1     excludeNamesFile = cliArgs['exclude-names-file'],
    1     list = cliArgs.list,
    1     nokeepgoing = not cliArgs['keep-going'],
    1     suppressPending = cliArgs['suppress-pending'],
        })

    1   if cliArgs.ROOT then
          -- Load test directories/files
    1     local rootFiles = cliArgs.ROOT
    1     local patterns = cliArgs.pattern
    1     local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
    2     testFileLoader(rootFiles, patterns, {
    1       excludes = cliArgs['exclude-pattern'],
    1       verbose = cliArgs.verbose,
    1       recursive = cliArgs['recursive'],
    1     })
        else
          -- Running standalone, use standalone loader
****0     local testFileLoader = require 'busted.modules.standalone_loader'(busted)
****0     testFileLoader(info, { verbose = cliArgs.verbose })
        end

    1   local runs = cliArgs['repeat']
    1   local execute = require 'busted.execute'(busted)
    2   execute(runs, {
    1     seed = cliArgs.seed,
    1     shuffle = cliArgs['shuffle-files'],
    1     sort = cliArgs['sort-files'],
        })

    1   busted.publish({ 'exit' })

    1   if options.standalone or failures > 0 or errors > 0 then
****0     exit(failures + errors, forceExit)
        end
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/status.lua
==============================================================================
      local function get_status(status)
  136   local smap = {
  136     ['success'] = 'success',
  136     ['pending'] = 'pending',
  136     ['failure'] = 'failure',
  136     ['error'] = 'error',
  136     ['true'] = 'success',
  136     ['false'] = 'failure',
  136     ['nil'] = 'error',
        }
  136   return smap[tostring(status)] or 'error'
      end

      return function(inital_status)
  117   local objstat = get_status(inital_status)
  117   local obj = {
  172     success = function(self) return (objstat == 'success') end,
  117     pending = function(self) return (objstat == 'pending') end,
  117     failure = function(self) return (objstat == 'failure') end,
  117     error   = function(self) return (objstat == 'error') end,

          get = function(self)
****0       return objstat
          end,

          set = function(self, status)
****0       objstat = get_status(status)
          end,

          update = function(self, status)
            -- prefer current failure/error status over new status
   19       status = get_status(status)
   19       if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
   19         objstat = status
            end
          end
        }

  234   return setmetatable(obj, {
  117     __index = {},
  155     __tostring = function(self) return objstat end
  117   })
      end

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/busted/utils.lua
==============================================================================
****0 return {
        copy_interpreter_args = function(arguments)
          -- copy non-positive command-line args auto-inserted by Lua interpreter
    1     if arguments and _G.arg then
    1       local i = 0
    5       while _G.arg[i] do
    4         arguments[i] = _G.arg[i]
    4         i = i - 1
            end
          end
        end,

        split = require 'pl.utils'.split,

        shuffle = function(t, seed)
****0     if seed then math.randomseed(seed) end
****0     local n = #t
****0     while n >= 2 do
****0       local k = math.random(n)
****0       t[n], t[k] = t[k], t[n]
****0       n = n - 1
          end
****0     return t
        end,

        urandom = function()
    1     local f = io.open('/dev/urandom', 'rb')
    1     if not f then return nil end
    1     local s = f:read(4) f:close()
    1     local bytes = {s:byte(1, 4)}
    1     local value = 0
    5     for _, v in ipairs(bytes) do
    4       value = value * 256 + v
          end
    1     return value
        end,
      }

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/inspect.lua
==============================================================================
    1 local _tl_compat; if (tonumber((_VERSION or ''):match('[%d.]*$')) or 0) < 5.3 then local p, m = pcall(require, 'compat53.module'); if p then _tl_compat = m end end; local math = _tl_compat and _tl_compat.math or math; local string = _tl_compat and _tl_compat.string or string; local table = _tl_compat and _tl_compat.table or table
    1 local inspect = {Options = {}, }

















    1 inspect._VERSION = 'inspect.lua 3.1.0'
    1 inspect._URL = 'http://github.com/kikito/inspect.lua'
    1 inspect._DESCRIPTION = 'human-readable representations of tables'
      inspect._LICENSE = [[
        MIT LICENSE

        Copyright (c) 2022 Enrique Garca Cota

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files (the
        "Software"), to deal in the Software without restriction, including
        without limitation the rights to use, copy, modify, merge, publish,
        distribute, sublicense, and/or sell copies of the Software, and to
        permit persons to whom the Software is furnished to do so, subject to
        the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    1 ]]
    1 inspect.KEY = setmetatable({}, { __tostring = function() return 'inspect.KEY' end })
    1 inspect.METATABLE = setmetatable({}, { __tostring = function() return 'inspect.METATABLE' end })

    1 local tostring = tostring
    1 local rep = string.rep
    1 local match = string.match
    1 local char = string.char
    1 local gsub = string.gsub
    1 local fmt = string.format

      local function rawpairs(t)
****0    return next, t, nil
      end



      local function smartQuote(str)
****0    if match(str, '"') and not match(str, "'") then
****0       return "'" .. str .. "'"
         end
****0    return '"' .. gsub(str, '"', '\\"') .. '"'
      end


    1 local shortControlCharEscapes = {
    1    ["\a"] = "\\a", ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
    1    ["\r"] = "\\r", ["\t"] = "\\t", ["\v"] = "\\v", ["\127"] = "\\127",
      }
    1 local longControlCharEscapes = { ["\127"] = "\127" }
   33 for i = 0, 31 do
   32    local ch = char(i)
   32    if not shortControlCharEscapes[ch] then
   25       shortControlCharEscapes[ch] = "\\" .. i
   25       longControlCharEscapes[ch] = fmt("\\%03d", i)
         end
      end

      local function escape(str)
****0    return (gsub(gsub(gsub(str, "\\", "\\\\"),
****0    "(%c)%f[0-9]", longControlCharEscapes),
****0    "%c", shortControlCharEscapes))
      end

      local function isIdentifier(str)
****0    return type(str) == "string" and not not str:match("^[_%a][_%a%d]*$")
      end

    1 local flr = math.floor
      local function isSequenceKey(k, sequenceLength)
****0    return type(k) == "number" and
****0    flr(k) == k and
****0    1 <= (k) and
****0    k <= sequenceLength
      end

    1 local defaultTypeOrders = {
    1    ['number'] = 1, ['boolean'] = 2, ['string'] = 3, ['table'] = 4,
    1    ['function'] = 5, ['userdata'] = 6, ['thread'] = 7,
      }

      local function sortKeys(a, b)
****0    local ta, tb = type(a), type(b)


****0    if ta == tb and (ta == 'string' or ta == 'number') then
****0       return (a) < (b)
         end

****0    local dta = defaultTypeOrders[ta] or 100
****0    local dtb = defaultTypeOrders[tb] or 100


****0    return dta == dtb and ta < tb or dta < dtb
      end

      local function getKeys(t)

****0    local seqLen = 1
****0    while rawget(t, seqLen) ~= nil do
****0       seqLen = seqLen + 1
         end
****0    seqLen = seqLen - 1

****0    local keys, keysLen = {}, 0
****0    for k in rawpairs(t) do
****0       if not isSequenceKey(k, seqLen) then
****0          keysLen = keysLen + 1
****0          keys[keysLen] = k
            end
         end
****0    table.sort(keys, sortKeys)
****0    return keys, keysLen, seqLen
      end

      local function countCycles(x, cycles)
****0    if type(x) == "table" then
****0       if cycles[x] then
****0          cycles[x] = cycles[x] + 1
            else
****0          cycles[x] = 1
****0          for k, v in rawpairs(x) do
****0             countCycles(k, cycles)
****0             countCycles(v, cycles)
               end
****0          countCycles(getmetatable(x), cycles)
            end
         end
      end

      local function makePath(path, a, b)
****0    local newPath = {}
****0    local len = #path
****0    for i = 1, len do newPath[i] = path[i] end

****0    newPath[len + 1] = a
****0    newPath[len + 2] = b

****0    return newPath
      end


      local function processRecursive(process,
         item,
         path,
         visited)
****0    if item == nil then return nil end
****0    if visited[item] then return visited[item] end

****0    local processed = process(item, path)
****0    if type(processed) == "table" then
****0       local processedCopy = {}
****0       visited[item] = processedCopy
            local processedKey

****0       for k, v in rawpairs(processed) do
****0          processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)
****0          if processedKey ~= nil then
****0             processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
               end
            end

****0       local mt = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
****0       if type(mt) ~= 'table' then mt = nil end
****0       setmetatable(processedCopy, mt)
****0       processed = processedCopy
         end
****0    return processed
      end

      local function puts(buf, str)
****0    buf.n = buf.n + 1
****0    buf[buf.n] = str
      end



    1 local Inspector = {}










    1 local Inspector_mt = { __index = Inspector }

      local function tabify(inspector)
****0    puts(inspector.buf, inspector.newline .. rep(inspector.indent, inspector.level))
      end

    1 function Inspector:getId(v)
****0    local id = self.ids[v]
****0    local ids = self.ids
****0    if not id then
****0       local tv = type(v)
****0       id = (ids[tv] or 0) + 1
****0       ids[v], ids[tv] = id, id
         end
****0    return tostring(id)
      end

    1 function Inspector:putValue(v)
****0    local buf = self.buf
****0    local tv = type(v)
****0    if tv == 'string' then
****0       puts(buf, smartQuote(escape(v)))
****0    elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
****0       tv == 'cdata' or tv == 'ctype' then
****0       puts(buf, tostring(v))
****0    elseif tv == 'table' and not self.ids[v] then
****0       local t = v

****0       if t == inspect.KEY or t == inspect.METATABLE then
****0          puts(buf, tostring(t))
****0       elseif self.level >= self.depth then
****0          puts(buf, '{...}')
            else
****0          if self.cycles[t] > 1 then puts(buf, fmt('<%d>', self:getId(t))) end

****0          local keys, keysLen, seqLen = getKeys(t)

****0          puts(buf, '{')
****0          self.level = self.level + 1

****0          for i = 1, seqLen + keysLen do
****0             if i > 1 then puts(buf, ',') end
****0             if i <= seqLen then
****0                puts(buf, ' ')
****0                self:putValue(t[i])
                  else
****0                local k = keys[i - seqLen]
****0                tabify(self)
****0                if isIdentifier(k) then
****0                   puts(buf, k)
                     else
****0                   puts(buf, "[")
****0                   self:putValue(k)
****0                   puts(buf, "]")
                     end
****0                puts(buf, ' = ')
****0                self:putValue(t[k])
                  end
               end

****0          local mt = getmetatable(t)
****0          if type(mt) == 'table' then
****0             if seqLen + keysLen > 0 then puts(buf, ',') end
****0             tabify(self)
****0             puts(buf, '<metatable> = ')
****0             self:putValue(mt)
               end

****0          self.level = self.level - 1

****0          if keysLen > 0 or type(mt) == 'table' then
****0             tabify(self)
****0          elseif seqLen > 0 then
****0             puts(buf, ' ')
               end

****0          puts(buf, '}')
            end

         else
****0       puts(buf, fmt('<%s %d>', tv, self:getId(v)))
         end
      end




    1 function inspect.inspect(root, options)
****0    options = options or {}

****0    local depth = options.depth or (math.huge)
****0    local newline = options.newline or '\n'
****0    local indent = options.indent or '  '
****0    local process = options.process

****0    if process then
****0       root = processRecursive(process, root, {}, {})
         end

****0    local cycles = {}
****0    countCycles(root, cycles)

****0    local inspector = setmetatable({
            buf = { n = 0 },
            ids = {},
            cycles = cycles,
            depth = depth,
            level = 0,
            newline = newline,
            indent = indent,
****0    }, Inspector_mt)

****0    inspector:putValue(root)

****0    return table.concat(inspector.buf)
      end

    2 setmetatable(inspect, {
         __call = function(_, root, options)
****0       return inspect.inspect(root, options)
         end,
      })

    1 return inspect

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/luassert/assert.lua
==============================================================================
****0 local s = require 'say'
****0 local astate = require 'luassert.state'
****0 local util = require 'luassert.util'
****0 local unpack = util.unpack
      local obj   -- the returned module table
****0 local level_mt = {}

      -- list of namespaces
****0 local namespace = require 'luassert.namespaces'

      local function geterror(assertion_message, failure_message, args)
****0   if util.hastostring(failure_message) then
****0     failure_message = tostring(failure_message)
****0   elseif failure_message ~= nil then
****0     failure_message = astate.format_argument(failure_message)
        end
****0   local message = s(assertion_message, obj:format(args))
****0   if message and failure_message then
****0     message = failure_message .. "\n" .. message
        end
****0   return message or failure_message
      end

****0 local __state_meta = {

        __call = function(self, ...)
   23     local keys = util.extract_keys("assertion", self.tokens)

          local assertion

   70     for _, key in ipairs(keys) do
   47       assertion = namespace.assertion[key] or assertion
          end

   23     if assertion then
   70       for _, key in ipairs(keys) do
   47         if namespace.modifier[key] then
   24           namespace.modifier[key].callback(self)
              end
            end

   23       local arguments = util.make_arglist(...)
   23       local val, retargs = assertion.callback(self, arguments, util.errorlevel())

   23       if (not val) == self.mod then
****0         local message = assertion.positive_message
****0         if not self.mod then
****0           message = assertion.negative_message
              end
****0         local err = geterror(message, rawget(self,"failure_message"), arguments)
****0         error(err or "assertion failed!", util.errorlevel())
            end

   23       if retargs then
****0         return unpack(retargs)
            end
   23       return ...
          else
****0       local arguments = util.make_arglist(...)
****0       self.tokens = {}

****0       for _, key in ipairs(keys) do
****0         if namespace.modifier[key] then
****0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
              end
            end
          end

****0     return self
        end,

        __index = function(self, key)
   91     for token in key:lower():gmatch('[^_]+') do
   47       table.insert(self.tokens, token)
          end

   44     return self
        end
      }

****0 obj = {
   23   state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,

        -- registers a function in namespace
        register = function(self, nspace, name, callback, positive_message, negative_message)
****0     local lowername = name:lower()
****0     if not namespace[nspace] then
****0       namespace[nspace] = {}
          end
****0     namespace[nspace][lowername] = {
            callback = callback,
            name = lowername,
            positive_message=positive_message,
****0       negative_message=negative_message
          }
        end,

        -- unregisters a function in a namespace
        unregister = function(self, nspace, name)
****0     local lowername = name:lower()
****0     if not namespace[nspace] then
****0       namespace[nspace] = {}
          end
****0     namespace[nspace][lowername] = nil
        end,

        -- registers a formatter
        -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
        add_formatter = function(self, callback)
****0     astate.add_formatter(callback)
        end,

        -- unregisters a formatter
        remove_formatter = function(self, fmtr)
****0     astate.remove_formatter(fmtr)
        end,

        format = function(self, args)
          -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
****0     local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
****0     local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
****0     for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
****0       if not nofmt[i] then
****0         local val = args[i]
****0         local valfmt = astate.format_argument(val, nil, fmtargs[i])
****0         if valfmt == nil then valfmt = tostring(val) end -- no formatter found
****0         args[i] = valfmt
            end
          end
****0     return args
        end,

        set_parameter = function(self, name, value)
****0     astate.set_parameter(name, value)
        end,

        get_parameter = function(self, name)
****0     return astate.get_parameter(name)
        end,

        add_spy = function(self, spy)
****0     astate.add_spy(spy)
        end,

        snapshot = function(self)
****0     return astate.snapshot()
        end,

        level = function(self, level)
****0     return setmetatable({
****0         level = level
****0       }, level_mt)
        end,

        -- returns the level if a level-value, otherwise nil
        get_level = function(self, level)
****0     if getmetatable(level) ~= level_mt then
****0       return nil -- not a valid error-level
          end
****0     return level.level
        end,
      }

****0 local __meta = {

        __call = function(self, bool, message, level, ...)
   21     if not bool then
****0       local err_level = (self:get_level(level) or 1) + 1
****0       error(message or "assertion failed!", err_level)
          end
   21     return bool , message , level , ...
        end,

        __index = function(self, key)
   23     return rawget(self, key) or self.state()[key]
        end,

      }

****0 return setmetatable(obj, __meta)

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/luassert/assertions.lua
==============================================================================
      -- module will not return anything, only register assertions with the main assert engine

      -- assertions take 2 parameters;
      -- 1) state
      -- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils
      -- 3) level The level of the error position relative to the called function
      -- returns; boolean; whether assertion passed

****0 local assert = require('luassert.assert')
****0 local astate = require ('luassert.state')
****0 local util = require ('luassert.util')
****0 local s = require('say')

      local function format(val)
****0   return astate.format_argument(val) or tostring(val)
      end

      local function set_failure_message(state, message)
   23   if message ~= nil then
    1     state.failure_message = message
        end
      end

      local function unique(state, arguments, level)
****0   local list = arguments[1]
        local deep
****0   local argcnt = arguments.n
****0   if type(arguments[2]) == "boolean" or (arguments[2] == nil and argcnt > 2) then
****0     deep = arguments[2]
****0     set_failure_message(state, arguments[3])
        else
****0     if type(arguments[3]) == "boolean" then
****0       deep = arguments[3]
          end
****0     set_failure_message(state, arguments[2])
        end
****0   for k,v in pairs(list) do
****0     for k2, v2 in pairs(list) do
****0       if k ~= k2 then
****0         if deep and util.deepcompare(v, v2, true) then
****0           return false
              else
****0           if v == v2 then
****0             return false
                end
              end
            end
          end
        end
****0   return true
      end

      local function near(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local argcnt = arguments.n
****0   assert(argcnt > 2, s("assertion.internal.argtolittle", { "near", 3, tostring(argcnt) }), level)
****0   local expected = tonumber(arguments[1])
****0   local actual = tonumber(arguments[2])
****0   local tolerance = tonumber(arguments[3])
****0   local numbertype = "number or object convertible to a number"
****0   assert(expected, s("assertion.internal.badargtype", { 1, "near", numbertype, format(arguments[1]) }), level)
****0   assert(actual, s("assertion.internal.badargtype", { 2, "near", numbertype, format(arguments[2]) }), level)
****0   assert(tolerance, s("assertion.internal.badargtype", { 3, "near", numbertype, format(arguments[3]) }), level)
        -- switch arguments for proper output message
****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
****0   arguments[3] = tolerance
****0   arguments.nofmt = arguments.nofmt or {}
****0   arguments.nofmt[3] = true
****0   set_failure_message(state, arguments[4])
****0   return (actual >= expected - tolerance and actual <= expected + tolerance)
      end

      local function matches(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local argcnt = arguments.n
****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "matches", 2, tostring(argcnt) }), level)
****0   local pattern = arguments[1]
        local actual = nil
****0   if util.hastostring(arguments[2]) or type(arguments[2]) == "number" then
****0     actual = tostring(arguments[2])
        end
        local err_message
****0   local init_arg_num = 3
****0   for i=3,argcnt,1 do
****0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
****0       if i == 3 then init_arg_num = init_arg_num + 1 end
****0       err_message = util.tremove(arguments, i)
            break
          end
        end
****0   local init = arguments[3]
****0   local plain = arguments[4]
****0   local stringtype = "string or object convertible to a string"
****0   assert(type(pattern) == "string", s("assertion.internal.badargtype", { 1, "matches", "string", type(arguments[1]) }), level)
****0   assert(actual, s("assertion.internal.badargtype", { 2, "matches", stringtype, format(arguments[2]) }), level)
****0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)
        -- switch arguments for proper output message
****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
****0   set_failure_message(state, err_message)
        local retargs
        local ok
****0   if plain then
****0     ok = (actual:find(pattern, init, plain) ~= nil)
****0     retargs = ok and { pattern } or {}
        else
****0     retargs = { actual:match(pattern, init) }
****0     ok = (retargs[1] ~= nil)
        end
****0   return ok, retargs
      end

      local function equals(state, arguments, level)
   20   local level = (level or 1) + 1
   20   local argcnt = arguments.n
   20   assert(argcnt > 1, s("assertion.internal.argtolittle", { "equals", 2, tostring(argcnt) }), level)
   20   local result =  arguments[1] == arguments[2]
        -- switch arguments for proper output message
   20   util.tinsert(arguments, 1, util.tremove(arguments, 2))
   20   set_failure_message(state, arguments[3])
   20   return result
      end

      local function same(state, arguments, level)
    1   local level = (level or 1) + 1
    1   local argcnt = arguments.n
    1   assert(argcnt > 1, s("assertion.internal.argtolittle", { "same", 2, tostring(argcnt) }), level)
    1   if type(arguments[1]) == 'table' and type(arguments[2]) == 'table' then
    1     local result, crumbs = util.deepcompare(arguments[1], arguments[2], true)
          -- switch arguments for proper output message
    1     util.tinsert(arguments, 1, util.tremove(arguments, 2))
    1     arguments.fmtargs = arguments.fmtargs or {}
    1     arguments.fmtargs[1] = { crumbs = crumbs }
    1     arguments.fmtargs[2] = { crumbs = crumbs }
    1     set_failure_message(state, arguments[3])
    1     return result
        end
****0   local result = arguments[1] == arguments[2]
        -- switch arguments for proper output message
****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
****0   set_failure_message(state, arguments[3])
****0   return result
      end

      local function truthy(state, arguments, level)
****0   local argcnt = arguments.n
****0   assert(argcnt > 0, s("assertion.internal.argtolittle", { "truthy", 1, tostring(argcnt) }), level)
****0   set_failure_message(state, arguments[2])
****0   return arguments[1] ~= false and arguments[1] ~= nil
      end

      local function falsy(state, arguments, level)
****0   local argcnt = arguments.n
****0   assert(argcnt > 0, s("assertion.internal.argtolittle", { "falsy", 1, tostring(argcnt) }), level)
****0   return not truthy(state, arguments, level)
      end

      local function has_error(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local retargs = util.shallowcopy(arguments)
****0   local func = arguments[1]
****0   local err_expected = arguments[2]
****0   local failure_message = arguments[3]
****0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error", "function or callable object", type(func) }), level)
****0   local ok, err_actual = pcall(func)
****0   if type(err_actual) == 'string' then
          -- remove 'path/to/file:line: ' from string
****0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
        end
****0   retargs[1] = err_actual
****0   arguments.nofmt = {}
****0   arguments.n = 2
****0   arguments[1] = (ok and '(no error)' or err_actual)
****0   arguments[2] = (err_expected == nil and '(error)' or err_expected)
****0   arguments.nofmt[1] = ok
****0   arguments.nofmt[2] = (err_expected == nil)
****0   set_failure_message(state, failure_message)

****0   if ok or err_expected == nil then
****0     return not ok, retargs
        end
****0   if type(err_expected) == 'string' then
          -- err_actual must be (convertible to) a string
****0     if util.hastostring(err_actual) then
****0       err_actual = tostring(err_actual)
****0       retargs[1] = err_actual
          end
****0     if type(err_actual) == 'string' then
****0       return err_expected == err_actual, retargs
          end
****0   elseif type(err_expected) == 'number' then
****0     if type(err_actual) == 'string' then
****0       return tostring(err_expected) == tostring(tonumber(err_actual)), retargs
          end
        end
****0   return same(state, {err_expected, err_actual, ["n"] = 2}), retargs
      end

      local function error_matches(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local retargs = util.shallowcopy(arguments)
****0   local argcnt = arguments.n
****0   local func = arguments[1]
****0   local pattern = arguments[2]
****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "error_matches", 2, tostring(argcnt) }), level)
****0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error_matches", "function or callable object", type(func) }), level)
****0   assert(pattern == nil or type(pattern) == "string", s("assertion.internal.badargtype", { 2, "error", "string", type(pattern) }), level)

        local failure_message
****0   local init_arg_num = 3
****0   for i=3,argcnt,1 do
****0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
****0       if i == 3 then init_arg_num = init_arg_num + 1 end
****0       failure_message = util.tremove(arguments, i)
            break
          end
        end
****0   local init = arguments[3]
****0   local plain = arguments[4]
****0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)

****0   local ok, err_actual = pcall(func)
****0   if type(err_actual) == 'string' then
          -- remove 'path/to/file:line: ' from string
****0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
        end
****0   retargs[1] = err_actual
****0   arguments.nofmt = {}
****0   arguments.n = 2
****0   arguments[1] = (ok and '(no error)' or err_actual)
****0   arguments[2] = pattern
****0   arguments.nofmt[1] = ok
****0   arguments.nofmt[2] = false
****0   set_failure_message(state, failure_message)

****0   if ok then return not ok, retargs end
****0   if err_actual == nil and pattern == nil then
****0     return true, {}
        end

        -- err_actual must be (convertible to) a string
****0   if util.hastostring(err_actual) or
****0      type(err_actual) == "number" or
****0      type(err_actual) == "boolean" then
****0     err_actual = tostring(err_actual)
****0     retargs[1] = err_actual
        end
****0   if type(err_actual) == 'string' then
          local ok
          local retargs_ok
****0     if plain then
****0       retargs_ok = { pattern }
****0       ok = (err_actual:find(pattern, init, plain) ~= nil)
          else
****0       retargs_ok = { err_actual:match(pattern, init) }
****0       ok = (retargs_ok[1] ~= nil)
          end
****0     if ok then retargs = retargs_ok end
****0     return ok, retargs
        end

****0   return false, retargs
      end

      local function is_true(state, arguments, level)
    1   util.tinsert(arguments, 2, true)
    1   set_failure_message(state, arguments[3])
    1   return arguments[1] == arguments[2]
      end

      local function is_false(state, arguments, level)
****0   util.tinsert(arguments, 2, false)
****0   set_failure_message(state, arguments[3])
****0   return arguments[1] == arguments[2]
      end

      local function is_type(state, arguments, level, etype)
    1   util.tinsert(arguments, 2, "type " .. etype)
    1   arguments.nofmt = arguments.nofmt or {}
    1   arguments.nofmt[2] = true
    1   set_failure_message(state, arguments[3])
    1   return arguments.n > 1 and type(arguments[1]) == etype
      end

      local function returned_arguments(state, arguments, level)
****0   arguments[1] = tostring(arguments[1])
****0   arguments[2] = tostring(arguments.n - 1)
****0   arguments.nofmt = arguments.nofmt or {}
****0   arguments.nofmt[1] = true
****0   arguments.nofmt[2] = true
****0   if arguments.n < 2 then arguments.n = 2 end
****0   return arguments[1] == arguments[2]
      end

      local function set_message(state, arguments, level)
****0   state.failure_message = arguments[1]
      end

****0 local function is_boolean(state, arguments, level)  return is_type(state, arguments, level, "boolean")  end
****0 local function is_number(state, arguments, level)   return is_type(state, arguments, level, "number")   end
****0 local function is_string(state, arguments, level)   return is_type(state, arguments, level, "string")   end
****0 local function is_table(state, arguments, level)    return is_type(state, arguments, level, "table")    end
    1 local function is_nil(state, arguments, level)      return is_type(state, arguments, level, "nil")      end
****0 local function is_userdata(state, arguments, level) return is_type(state, arguments, level, "userdata") end
****0 local function is_function(state, arguments, level) return is_type(state, arguments, level, "function") end
****0 local function is_thread(state, arguments, level)   return is_type(state, arguments, level, "thread")   end

****0 assert:register("modifier", "message", set_message)
****0 assert:register("assertion", "true", is_true, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "false", is_false, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "boolean", is_boolean, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "number", is_number, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "string", is_string, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "table", is_table, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "nil", is_nil, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "userdata", is_userdata, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "function", is_function, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "thread", is_thread, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "returned_arguments", returned_arguments, "assertion.returned_arguments.positive", "assertion.returned_arguments.negative")

****0 assert:register("assertion", "same", same, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "matches", matches, "assertion.matches.positive", "assertion.matches.negative")
****0 assert:register("assertion", "match", matches, "assertion.matches.positive", "assertion.matches.negative")
****0 assert:register("assertion", "near", near, "assertion.near.positive", "assertion.near.negative")
****0 assert:register("assertion", "equals", equals, "assertion.equals.positive", "assertion.equals.negative")
****0 assert:register("assertion", "equal", equals, "assertion.equals.positive", "assertion.equals.negative")
****0 assert:register("assertion", "unique", unique, "assertion.unique.positive", "assertion.unique.negative")
****0 assert:register("assertion", "error", has_error, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "errors", has_error, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "error_matches", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "error_match", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "matches_error", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "match_error", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "truthy", truthy, "assertion.truthy.positive", "assertion.truthy.negative")
****0 assert:register("assertion", "falsy", falsy, "assertion.falsy.positive", "assertion.falsy.negative")

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/luassert/modifiers.lua
==============================================================================
      -- module will not return anything, only register assertions/modifiers with the main assert engine
****0 local assert = require('luassert.assert')

      local function is(state)
   23   return state
      end

      local function is_not(state)
    1   state.mod = not state.mod
    1   return state
      end

****0 assert:register("modifier", "is", is)
****0 assert:register("modifier", "are", is)
****0 assert:register("modifier", "was", is)
****0 assert:register("modifier", "has", is)
****0 assert:register("modifier", "does", is)
****0 assert:register("modifier", "not", is_not)
****0 assert:register("modifier", "no", is_not)

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/luassert/util.lua
==============================================================================
****0 local util = {}
****0 local arglist_mt = {}

      -- have pack/unpack both respect the 'n' field
****0 local _unpack = table.unpack or unpack
****0 local unpack = function(t, i, j) return _unpack(t, i or 1, j or t.n or #t) end
****0 local pack = function(...) return { n = select("#", ...), ... } end
****0 util.pack = pack
****0 util.unpack = unpack


****0 function util.deepcompare(t1,t2,ignore_mt,cycles,thresh1,thresh2)
    7   local ty1 = type(t1)
    7   local ty2 = type(t2)
        -- non-table types can be directly compared
    7   if ty1 ~= 'table' or ty2 ~= 'table' then return t1 == t2 end
    1   local mt1 = debug.getmetatable(t1)
    1   local mt2 = debug.getmetatable(t2)
        -- would equality be determined by metatable __eq?
    1   if mt1 and mt1 == mt2 and mt1.__eq then
          -- then use that unless asked not to
****0     if not ignore_mt then return t1 == t2 end
        else -- we can skip the deep comparison below if t1 and t2 share identity
    1     if rawequal(t1, t2) then return true end
        end

        -- handle recursive tables
    1   cycles = cycles or {{},{}}
    1   thresh1, thresh2 = (thresh1 or 1), (thresh2 or 1)
    1   cycles[1][t1] = (cycles[1][t1] or 0)
    1   cycles[2][t2] = (cycles[2][t2] or 0)
    1   if cycles[1][t1] == 1 or cycles[2][t2] == 1 then
****0     thresh1 = cycles[1][t1] + 1
****0     thresh2 = cycles[2][t2] + 1
        end
    1   if cycles[1][t1] > thresh1 and cycles[2][t2] > thresh2 then
****0     return true
        end

    1   cycles[1][t1] = cycles[1][t1] + 1
    1   cycles[2][t2] = cycles[2][t2] + 1

    7   for k1,v1 in next, t1 do
    6     local v2 = t2[k1]
    6     if v2 == nil then
****0       return false, {k1}
          end

    6     local same, crumbs = util.deepcompare(v1,v2,nil,cycles,thresh1,thresh2)
    6     if not same then
****0       crumbs = crumbs or {}
****0       table.insert(crumbs, k1)
****0       return false, crumbs
          end
        end
    7   for k2,_ in next, t2 do
          -- only check whether each element has a t1 counterpart, actual comparison
          -- has been done in first loop above
    6     if t1[k2] == nil then return false, {k2} end
        end

    1   cycles[1][t1] = cycles[1][t1] - 1
    1   cycles[2][t2] = cycles[2][t2] - 1

    1   return true
      end

****0 function util.shallowcopy(t)
****0   if type(t) ~= "table" then return t end
****0   local copy = {}
****0   setmetatable(copy, getmetatable(t))
****0   for k,v in next, t do
****0     copy[k] = v
        end
****0   return copy
      end

****0 function util.deepcopy(t, deepmt, cache)
****0   local spy = require 'luassert.spy'
****0   if type(t) ~= "table" then return t end
****0   local copy = {}

        -- handle recursive tables
****0   local cache = cache or {}
****0   if cache[t] then return cache[t] end
****0   cache[t] = copy

****0   for k,v in next, t do
****0     copy[k] = (spy.is_spy(v) and v or util.deepcopy(v, deepmt, cache))
        end
****0   if deepmt then
****0     debug.setmetatable(copy, util.deepcopy(debug.getmetatable(t), false, cache))
        else
****0     debug.setmetatable(copy, debug.getmetatable(t))
        end
****0   return copy
      end

      -----------------------------------------------
      -- Copies arguments as a list of arguments
      -- @param args the arguments of which to copy
      -- @return the copy of the arguments
****0 function util.copyargs(args)
****0   local copy = {}
****0   setmetatable(copy, getmetatable(args))
****0   local match = require 'luassert.match'
****0   local spy = require 'luassert.spy'
****0   for k,v in pairs(args) do
****0     copy[k] = ((match.is_matcher(v) or spy.is_spy(v)) and v or util.deepcopy(v))
        end
****0   return { vals = copy, refs = util.shallowcopy(args) }
      end

      -----------------------------------------------
      -- Clear an arguments or return values list from a table
      -- @param arglist the table to clear of arguments or return values and their count
      -- @return No return values
****0 function util.cleararglist(arglist)
****0   for idx = arglist.n, 1, -1 do
****0     util.tremove(arglist, idx)
        end
****0   arglist.n = nil
      end

      -----------------------------------------------
      -- Test specs against an arglist in deepcopy and refs flavours.
      -- @param args deepcopy arglist
      -- @param argsrefs refs arglist
      -- @param specs arguments/return values to match against args/argsrefs
      -- @return true if specs match args/argsrefs, false otherwise
      local function matcharg(args, argrefs, specs)
****0   local match = require 'luassert.match'
****0   for idx, argval in pairs(args) do
****0     local spec = specs[idx]
****0     if match.is_matcher(spec) then
****0       if match.is_ref_matcher(spec) then
****0         argval = argrefs[idx]
            end
****0       if not spec(argval) then
****0         return false
            end
****0     elseif (spec == nil or not util.deepcompare(argval, spec)) then
****0       return false
          end
        end

****0   for idx, spec in pairs(specs) do
          -- only check whether each element has an args counterpart,
          -- actual comparison has been done in first loop above
****0     local argval = args[idx]
****0     if argval == nil then
            -- no args counterpart, so try to compare using matcher
****0       if match.is_matcher(spec) then
****0         if not spec(argval) then
****0           return false
              end
            else
****0         return false
            end
          end
        end
****0   return true
      end

      -----------------------------------------------
      -- Find matching arguments/return values in a saved list of
      -- arguments/returned values.
      -- @param invocations_list list of arguments/returned values to search (list of lists)
      -- @param specs arguments/return values to match against argslist
      -- @return the last matching arguments/returned values if a match is found, otherwise nil
****0 function util.matchargs(invocations_list, specs)
        -- Search the arguments/returned values last to first to give the
        -- most helpful answer possible. In the cases where you can place
        -- your assertions between calls to check this gives you the best
        -- information if no calls match. In the cases where you can't do
        -- that there is no good way to predict what would work best.
****0   assert(not util.is_arglist(invocations_list), "expected a list of arglist-object, got an arglist")
****0   for ii = #invocations_list, 1, -1 do
****0     local val = invocations_list[ii]
****0     if matcharg(val.vals, val.refs, specs) then
****0       return val
          end
        end
****0   return nil
      end

      -----------------------------------------------
      -- Find matching oncall for an actual call.
      -- @param oncalls list of oncalls to search
      -- @param args actual call argslist to match against
      -- @return the first matching oncall if a match is found, otherwise nil
****0 function util.matchoncalls(oncalls, args)
****0   for _, callspecs in ipairs(oncalls) do
          -- This lookup is done immediately on *args* passing into the stub
          -- so pass *args* as both *args* and *argsref* without copying
          -- either.
****0     if matcharg(args, args, callspecs.vals) then
****0       return callspecs
          end
        end
****0   return nil
      end

      -----------------------------------------------
      -- table.insert() replacement that respects nil values.
      -- The function will use table field 'n' as indicator of the
      -- table length, if not set, it will be added.
      -- @param t table into which to insert
      -- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!
      -- @param val value to insert
      -- @return No return values
****0 function util.tinsert(...)
        -- check optional POS value
   23   local args = {...}
   23   local c = select('#',...)
   23   local t = args[1]
   23   local pos = args[2]
   23   local val = args[3]
   23   if c < 3 then
****0     val = pos
****0     pos = nil
        end
        -- set length indicator n if not present (+1)
   23   t.n = (t.n or #t) + 1
   23   if not pos then
****0     pos = t.n
   23   elseif pos > t.n then
          -- out of our range
****0     t[pos] = val
****0     t.n = pos
        end
        -- shift everything up 1 pos
   45   for i = t.n, pos + 1, -1 do
   22     t[i]=t[i-1]
        end
        -- add element to be inserted
   23   t[pos] = val
      end
      -----------------------------------------------
      -- table.remove() replacement that respects nil values.
      -- The function will use table field 'n' as indicator of the
      -- table length, if not set, it will be added.
      -- @param t table from which to remove
      -- @param pos (optional) position in table to remove
      -- @return No return values
****0 function util.tremove(t, pos)
        -- set length indicator n if not present (+1)
   21   t.n = t.n or #t
   21   if not pos then
****0     pos = t.n
   21   elseif pos > t.n then
****0     local removed = t[pos]
          -- out of our range
****0     t[pos] = nil
****0     return removed
        end
   21   local removed = t[pos]
        -- shift everything up 1 pos
   42   for i = pos, t.n do
   21     t[i]=t[i+1]
        end
        -- set size, clean last
   21   t[t.n] = nil
   21   t.n = t.n - 1
   21   return removed
      end

      -----------------------------------------------
      -- Checks an element to be callable.
      -- The type must either be a function or have a metatable
      -- containing an '__call' function.
      -- @param object element to inspect on being callable or not
      -- @return boolean, true if the object is callable
****0 function util.callable(object)
****0   return type(object) == "function" or type((debug.getmetatable(object) or {}).__call) == "function"
      end

      -----------------------------------------------
      -- Checks an element has tostring.
      -- The type must either be a string or have a metatable
      -- containing an '__tostring' function.
      -- @param object element to inspect on having tostring or not
      -- @return boolean, true if the object has tostring
****0 function util.hastostring(object)
****0   return type(object) == "string" or type((debug.getmetatable(object) or {}).__tostring) == "function"
      end

      -----------------------------------------------
      -- Find the first level, not defined in the same file as the caller's
      -- code file to properly report an error.
      -- @param level the level to use as the caller's source file
      -- @return number, the level of which to report an error
****0 function util.errorlevel(level)
   23   local level = (level or 1) + 1 -- add one to get level of the caller
   23   local info = debug.getinfo(level)
   23   local source = (info or {}).source
   23   local file = source
   46   while file and (file == source or source == "=(tail call)") do
   23     level = level + 1
   23     info = debug.getinfo(level)
   23     source = (info or {}).source
        end
   23   if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself
   23   return level
      end

      -----------------------------------------------
      -- Extract modifier and namespace keys from list of tokens.
      -- @param nspace the namespace from which to match tokens
      -- @param tokens list of tokens to search for keys
      -- @return table, list of keys that were extracted
****0 function util.extract_keys(nspace, tokens)
   23   local namespace = require 'luassert.namespaces'

        -- find valid keys by coalescing tokens as needed, starting from the end
   23   local keys = {}
   23   local key = nil
   23   local i = #tokens
   70   while i > 0 do
   47     local token = tokens[i]
   47     key = key and (token .. '_' .. key) or token

          -- find longest matching key in the given namespace
   47     local longkey = i > 1 and (tokens[i-1] .. '_' .. key) or nil
   47     while i > 1 and longkey and namespace[nspace][longkey] do
****0       key = longkey
****0       i = i - 1
****0       token = tokens[i]
****0       longkey = (token .. '_' .. key)
          end

   47     if namespace.modifier[key] or namespace[nspace][key] then
   47       table.insert(keys, 1, key)
   47       key = nil
          end
   47     i = i - 1
        end

        -- if there's anything left we didn't recognize it
   23   if key then
****0     error("luassert: unknown modifier/" .. nspace .. ": '" .. key .."'", util.errorlevel(2))
        end

   23   return keys
      end

      -----------------------------------------------
      -- store argument list for return values of a function in a table.
      -- The table will get a metatable to identify it as an arglist
****0 function util.make_arglist(...)
   23   local arglist = { ... }
   23   arglist.n = select('#', ...) -- add values count for trailing nils
   23   return setmetatable(arglist, arglist_mt)
      end

      -----------------------------------------------
      -- check a table to be an arglist type.
****0 function util.is_arglist(object)
****0   return getmetatable(object) == arglist_mt
      end

****0 return util

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/mediator.lua
==============================================================================
      local function getUniqueId(obj)
   34   return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
      end

      local function Subscriber(fn, options)
   34   local sub = {
   34     options = options or {},
   34     fn = fn,
   34     channel = nil,
          update = function(self, options)
****0       if options then
****0         self.fn = options.fn or self.fn
****0         self.options = options.options or self.options
            end
          end
        }
   34   sub.id = getUniqueId(sub)
   34   return sub
      end

      -- Channel class and functions --

      local function Channel(namespace, parent)
   26   return {
   26     stopped = false,
   26     namespace = namespace,
   26     callbacks = {},
   26     channels = {},
   26     parent = parent,

          addSubscriber = function(self, fn, options)
   34       local callback = Subscriber(fn, options)
   34       local priority = (#self.callbacks + 1)

   34       options = options or {}

   34       if options.priority and
   23         options.priority >= 0 and
   23         options.priority < priority
            then
   18           priority = options.priority
            end

   34       table.insert(self.callbacks, priority, callback)

   34       return callback
          end,

          getSubscriber = function(self, id)
****0       for i=1, #self.callbacks do
****0         local callback = self.callbacks[i]
****0         if callback.id == id then return { index = i, value = callback } end
            end
            local sub
****0       for _, channel in pairs(self.channels) do
****0         sub = channel:getSubscriber(id)
****0         if sub then break end
            end
****0       return sub
          end,

          setPriority = function(self, id, priority)
****0       local callback = self:getSubscriber(id)

****0       if callback.value then
****0         table.remove(self.callbacks, callback.index)
****0         table.insert(self.callbacks, priority, callback.value)
            end
          end,

          addChannel = function(self, namespace)
   26       self.channels[namespace] = Channel(namespace, self)
   26       return self.channels[namespace]
          end,

          hasChannel = function(self, namespace)
****0       return namespace and self.channels[namespace] and true
          end,

          getChannel = function(self, namespace)
  216       return self.channels[namespace] or self:addChannel(namespace)
          end,

          removeSubscriber = function(self, id)
****0       local callback = self:getSubscriber(id)

****0       if callback and callback.value then
****0         for _, channel in pairs(self.channels) do
****0           channel:removeSubscriber(id)
              end

****0         return table.remove(self.callbacks, callback.index)
            end
          end,

          publish = function(self, result, ...)
  352       for i = 1, #self.callbacks do
  194         local callback = self.callbacks[i]

              -- if it doesn't have a predicate, or it does and it's true then run it
  194         if not callback.options.predicate or callback.options.predicate(...) then
                 -- just take the first result and insert it into the result table
  194           local value, continue = callback.fn(...)

  194           if value then table.insert(result, value) end
  194           if not continue then return result end
              end
            end

  158       if parent then
  105         return parent:publish(result, ...)
            else
   53         return result
            end
          end
   26   }
      end

      -- Mediator class and functions --

****0 local Mediator = setmetatable(
      {
        Channel = Channel,
****0   Subscriber = Subscriber
      },
      {
        __call = function (fn, options)
****0     return {
            channel = Channel('root'),

            getChannel = function(self, channelNamespace)
  111         local channel = self.channel

  327         for i=1, #channelNamespace do
  216           channel = channel:getChannel(channelNamespace[i])
              end

  111         return channel
            end,

            subscribe = function(self, channelNamespace, fn, options)
   34         return self:getChannel(channelNamespace):addSubscriber(fn, options)
            end,

            getSubscriber = function(self, id, channelNamespace)
****0         return self:getChannel(channelNamespace):getSubscriber(id)
            end,

            removeSubscriber = function(self, id, channelNamespace)
****0         return self:getChannel(channelNamespace):removeSubscriber(id)
            end,

            publish = function(self, channelNamespace, ...)
   77         return self:getChannel(channelNamespace):publish({}, ...)
            end
          }
        end
      })
****0 return Mediator

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/pl/dir.lua
==============================================================================
      --- Listing files in directories and creating/removing directory paths.
      --
      -- Dependencies: `pl.utils`, `pl.path`
      --
      -- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
      -- @module pl.dir

    1 local utils = require 'pl.utils'
    1 local path = require 'pl.path'
    1 local is_windows = path.is_windows
    1 local ldir = path.dir
    1 local mkdir = path.mkdir
    1 local rmdir = path.rmdir
    1 local sub = string.sub
    1 local os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable
    1 local remove = os.remove
    1 local append = table.insert
    1 local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

    1 local exists, isdir = path.exists, path.isdir
    1 local sep = path.sep

    1 local dir = {}

      local function makelist(l)
****0     return setmetatable(l, require('pl.List'))
      end

      local function assert_dir (n,val)
****0     assert_arg(n,val,'string',path.isdir,'not a directory',4)
      end

      local function filemask(mask)
****0     mask = utils.escape(path.normcase(mask))
****0     return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'
      end

      --- Test whether a file name matches a shell pattern.
      -- Both parameters are case-normalized if operating system is
      -- case-insensitive.
      -- @string filename A file name.
      -- @string pattern A shell pattern. The only special characters are
      -- `'*'` and `'?'`: `'*'` matches any sequence of characters and
      -- `'?'` matches any single character.
      -- @treturn bool
      -- @raise dir and mask must be strings
    1 function dir.fnmatch(filename,pattern)
****0     assert_string(1,filename)
****0     assert_string(2,pattern)
****0     return path.normcase(filename):find(filemask(pattern)) ~= nil
      end

      --- Return a list of all file names within an array which match a pattern.
      -- @tab filenames An array containing file names.
      -- @string pattern A shell pattern (see `fnmatch`).
      -- @treturn List(string) List of matching file names.
      -- @raise dir and mask must be strings
    1 function dir.filter(filenames,pattern)
****0     assert_arg(1,filenames,'table')
****0     assert_string(2,pattern)
****0     local res = {}
****0     local mask = filemask(pattern)
****0     for i,f in ipairs(filenames) do
****0         if path.normcase(f):find(mask) then append(res,f) end
          end
****0     return makelist(res)
      end

      local function _listfiles(dirname,filemode,match)
****0     local res = {}
****0     local check = utils.choose(filemode,path.isfile,path.isdir)
****0     if not dirname then dirname = '.' end
****0     for f in ldir(dirname) do
****0         if f ~= '.' and f ~= '..' then
****0             local p = path.join(dirname,f)
****0             if check(p) and (not match or match(f)) then
****0                 append(res,p)
                  end
              end
          end
****0     return makelist(res)
      end

      --- return a list of all files in a directory which match a shell pattern.
      -- @string[opt='.'] dirname A directory.
      -- @string[opt] mask A shell pattern (see `fnmatch`). If not given, all files are returned.
      -- @treturn {string} list of files
      -- @raise dirname and mask must be strings
    1 function dir.getfiles(dirname,mask)
****0     dirname = dirname or '.'
****0     assert_dir(1,dirname)
****0     if mask then assert_string(2,mask) end
          local match
****0     if mask then
****0         mask = filemask(mask)
              match = function(f)
****0             return path.normcase(f):find(mask)
              end
          end
****0     return _listfiles(dirname,true,match)
      end

      --- return a list of all subdirectories of the directory.
      -- @string[opt='.'] dirname A directory.
      -- @treturn {string} a list of directories
      -- @raise dir must be a valid directory
    1 function dir.getdirectories(dirname)
****0     dirname = dirname or '.'
****0     assert_dir(1,dirname)
****0     return _listfiles(dirname,false)
      end

      local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

      local function execute_command(cmd,parms)
****0    if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
****0    local err = path.is_windows and ' > ' or ' 2> '
****0     cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)
****0     local ret = utils.execute(cmd)
****0     if not ret then
****0         local err = (utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
****0         remove(cmd_tmpfile)
****0         return false,err
          else
****0         remove(cmd_tmpfile)
****0         return true
          end
      end

      local function find_ffi_copyfile ()
****0     if not ffi_checked then
****0         ffi_checked = true
              local res
****0         res,alien = pcall(require,'alien')
****0         if not res then
****0             alien = nil
****0             res, ffi = pcall(require,'ffi')
              end
****0         if not res then
****0             ffi = nil
****0             return
              end
          else
****0         return
          end
****0     if alien then
              -- register the Win32 CopyFile and MoveFile functions
****0         local kernel = alien.load('kernel32.dll')
****0         CopyFile = kernel.CopyFileA
****0         CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
****0         MoveFile = kernel.MoveFileA
****0         MoveFile:types{'string','string',ret='int',abi='stdcall'}
****0         GetLastError = kernel.GetLastError
****0         GetLastError:types{ret ='int', abi='stdcall'}
****0     elseif ffi then
****0         ffi.cdef [[
                  int CopyFileA(const char *src, const char *dest, int iovr);
                  int MoveFileA(const char *src, const char *dest);
                  int GetLastError();
****0         ]]
****0         CopyFile = ffi.C.CopyFileA
****0         MoveFile = ffi.C.MoveFileA
****0         GetLastError = ffi.C.GetLastError
          end
****0     win32_errors = {
              ERROR_FILE_NOT_FOUND    =         2,
              ERROR_PATH_NOT_FOUND    =         3,
              ERROR_ACCESS_DENIED    =          5,
              ERROR_WRITE_PROTECT    =          19,
              ERROR_BAD_UNIT         =          20,
              ERROR_NOT_READY        =          21,
              ERROR_WRITE_FAULT      =          29,
              ERROR_READ_FAULT       =          30,
              ERROR_SHARING_VIOLATION =         32,
              ERROR_LOCK_VIOLATION    =         33,
              ERROR_HANDLE_DISK_FULL  =         39,
              ERROR_BAD_NETPATH       =         53,
              ERROR_NETWORK_BUSY      =         54,
              ERROR_DEV_NOT_EXIST     =         55,
              ERROR_FILE_EXISTS       =         80,
              ERROR_OPEN_FAILED       =         110,
              ERROR_INVALID_NAME      =         123,
              ERROR_BAD_PATHNAME      =         161,
              ERROR_ALREADY_EXISTS    =         183,
          }
      end

      local function two_arguments (f1,f2)
****0     return utils.quote_arg(f1)..' '..utils.quote_arg(f2)
      end

      local function file_op (is_copy,src,dest,flag)
****0     if flag == 1 and path.exists(dest) then
****0         return false,"cannot overwrite destination"
          end
****0     if is_windows then
              -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
****0         find_ffi_copyfile()
              -- fallback if there's no Alien, just use DOS commands *shudder*
              -- 'rename' involves a copy and then deleting the source.
****0         if not CopyFile then
****0             if path.is_windows then
****0                 src = src:gsub("/","\\")
****0                 dest = dest:gsub("/","\\")
                  end
****0             local res, err = execute_command('copy',two_arguments(src,dest))
****0             if not res then return false,err end
****0             if not is_copy then
****0                 return execute_command('del',utils.quote_arg(src))
                  end
****0             return true
              else
****0             if path.isdir(dest) then
****0                 dest = path.join(dest,path.basename(src))
                  end
                  local ret
****0             if is_copy then ret = CopyFile(src,dest,flag)
****0             else ret = MoveFile(src,dest) end
****0             if ret == 0 then
****0                 local err = GetLastError()
****0                 for name,value in pairs(win32_errors) do
****0                     if value == err then return false,name end
                      end
****0                 return false,"Error #"..err
****0             else return true
                  end
              end
          else -- for Unix, just use cp for now
****0         return execute_command(is_copy and 'cp' or 'mv',
****0             two_arguments(src,dest))
          end
      end

      --- copy a file.
      -- @string src source file
      -- @string dest destination file or directory
      -- @bool flag true if you want to force the copy (default)
      -- @treturn bool operation succeeded
      -- @raise src and dest must be strings
    1 function dir.copyfile (src,dest,flag)
****0     assert_string(1,src)
****0     assert_string(2,dest)
****0     flag = flag==nil or flag
****0     return file_op(true,src,dest,flag and 0 or 1)
      end

      --- move a file.
      -- @string src source file
      -- @string dest destination file or directory
      -- @treturn bool operation succeeded
      -- @raise src and dest must be strings
    1 function dir.movefile (src,dest)
****0     assert_string(1,src)
****0     assert_string(2,dest)
****0     return file_op(false,src,dest,0)
      end

      local function _dirfiles(dirname,attrib)
****0     local dirs = {}
****0     local files = {}
****0     for f in ldir(dirname) do
****0         if f ~= '.' and f ~= '..' then
****0             local p = path.join(dirname,f)
****0             local mode = attrib(p,'mode')
****0             if mode=='directory' then
****0                 append(dirs,f)
                  else
****0                 append(files,f)
                  end
              end
          end
****0     return makelist(dirs), makelist(files)
      end


      --- return an iterator which walks through a directory tree starting at root.
      -- The iterator returns (root,dirs,files)
      -- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
      -- to get the actual full path)
      -- If bottom_up is false (or not present), then the entries at the current level are returned
      -- before we go deeper. This means that you can modify the returned list of directories before
      -- continuing.
      -- This is a clone of os.walk from the Python libraries.
      -- @string root A starting directory
      -- @bool bottom_up False if we start listing entries immediately.
      -- @bool follow_links follow symbolic links
      -- @return an iterator returning root,dirs,files
      -- @raise root must be a directory
    1 function dir.walk(root,bottom_up,follow_links)
****0     assert_dir(1,root)
          local attrib
****0     if path.is_windows or not follow_links then
****0         attrib = path.attrib
          else
****0         attrib = path.link_attrib
          end

****0     local to_scan = { root }
****0     local to_return = {}
          local iter = function()
****0         while #to_scan > 0 do
****0             local current_root = table.remove(to_scan)
****0             local dirs,files = _dirfiles(current_root, attrib)
****0             for _, d in ipairs(dirs) do
****0                 table.insert(to_scan, current_root..path.sep..d)
                  end
****0             if not bottom_up then
****0                 return current_root, dirs, files
                  else
****0                 table.insert(to_return, { current_root, dirs, files })
                  end
              end
****0         if #to_return > 0 then
****0             return utils.unpack(table.remove(to_return))
              end
          end

****0     return iter
      end

      --- remove a whole directory tree.
      -- Symlinks in the tree will be deleted without following them.
      -- @string fullpath A directory path (must be an actual directory, not a symlink)
      -- @return true or nil
      -- @return error if failed
      -- @raise fullpath must be a string
    1 function dir.rmtree(fullpath)
****0     assert_dir(1,fullpath)
****0     if path.islink(fullpath) then return false,'will not follow symlink' end
****0     for root,dirs,files in dir.walk(fullpath,true) do
****0         if path.islink(root) then
                  -- sub dir is a link, remove link, do not follow
****0             if is_windows then
                      -- Windows requires using "rmdir". Deleting the link like a file
                      -- will instead delete all files from the target directory!!
****0                 local res, err = rmdir(root)
****0                 if not res then return nil,err .. ": " .. root end
                  else
****0                 local res, err = remove(root)
****0                 if not res then return nil,err .. ": " .. root end
                  end
              else
****0             for i,f in ipairs(files) do
****0                 local res, err = remove(path.join(root,f))
****0                 if not res then return nil,err .. ": " .. path.join(root,f) end
                  end
****0             local res, err = rmdir(root)
****0             if not res then return nil,err .. ": " .. root end
              end
          end
****0     return true
      end


      do
        local dirpat
    1   if path.is_windows then
****0       dirpat = '(.+)\\[^\\]+$'
        else
    1       dirpat = '(.+)/[^/]+$'
        end

        local _makepath
****0   function _makepath(p)
            -- windows root drive case
****0       if p:find '^%a:[\\]*$' then
****0           return true
            end
****0       if not path.isdir(p) then
****0           local subp = p:match(dirpat)
****0           if subp then
****0             local ok, err = _makepath(subp)
****0             if not ok then return nil, err end
                end
****0           return mkdir(p)
            else
****0           return true
            end
        end

        --- create a directory path.
        -- This will create subdirectories as necessary!
        -- @string p A directory path
        -- @return true on success, nil + errormsg on failure
        -- @raise failure to create
    1   function dir.makepath (p)
****0       assert_string(1,p)
****0       if path.is_windows then
****0           p = p:gsub("/", "\\")
            end
****0       return _makepath(path.abspath(p))
        end
      end

      --- clone a directory tree. Will always try to create a new directory structure
      -- if necessary.
      -- @string path1 the base path of the source tree
      -- @string path2 the new base path for the destination
      -- @func file_fun an optional function to apply on all files
      -- @bool verbose an optional boolean to control the verbosity of the output.
      --  It can also be a logging function that behaves like print()
      -- @return true, or nil
      -- @return error message, or list of failed directory creations
      -- @return list of failed file operations
      -- @raise path1 and path2 must be strings
      -- @usage clonetree('.','../backup',copyfile)
    1 function dir.clonetree (path1,path2,file_fun,verbose)
****0     assert_string(1,path1)
****0     assert_string(2,path2)
****0     if verbose == true then verbose = print end
****0     local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
****0     local faildirs,failfiles = {},{}
****0     if not isdir(path1) then return raise 'source is not a valid directory' end
****0     path1 = abspath(normcase(path1))
****0     path2 = abspath(normcase(path2))
****0     if verbose then verbose('normalized:',path1,path2) end
          -- particularly NB that the new path isn't fully contained in the old path
****0     if path1 == path2 then return raise "paths are the same" end
****0     local _,i2 = path2:find(path1,1,true)
****0     if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
****0         return raise 'destination is a subdirectory of the source'
          end
****0     local cp = path.common_prefix (path1,path2)
****0     local idx = #cp
****0     if idx == 0 then -- no common path, but watch out for Windows paths!
****0         if path1:sub(2,2) == ':' then idx = 3 end
          end
****0     for root,dirs,files in dir.walk(path1) do
****0         local opath = path2..root:sub(idx)
****0         if verbose then verbose('paths:',opath,root) end
****0         if not isdir(opath) then
****0             local ret = dir.makepath(opath)
****0             if not ret then append(faildirs,opath) end
****0             if verbose then verbose('creating:',opath,ret) end
              end
****0         if file_fun then
****0             for i,f in ipairs(files) do
****0                 local p1 = join(root,f)
****0                 local p2 = join(opath,f)
****0                 local ret = file_fun(p1,p2)
****0                 if not ret then append(failfiles,p2) end
****0                 if verbose then
****0                     verbose('files:',p1,p2,ret)
                      end
                  end
              end
          end
****0     return true,faildirs,failfiles
      end


      -- each entry of the stack is an array with three items:
      -- 1. the name of the directory
      -- 2. the lfs iterator function
      -- 3. the lfs iterator userdata
      local function treeiter(iterstack)
****0     local diriter = iterstack[#iterstack]
****0     if not diriter then
****0       return -- done
          end

****0     local dirname = diriter[1]
****0     local entry = diriter[2](diriter[3])
****0     if not entry then
****0       table.remove(iterstack)
****0       return treeiter(iterstack) -- tail-call to try next
          end

****0     if entry ~= "." and entry ~= ".." then
****0         entry = dirname .. sep .. entry
****0         if exists(entry) then  -- Just in case a symlink is broken.
****0             local is_dir = isdir(entry)
****0             if is_dir then
****0                 table.insert(iterstack, { entry, ldir(entry) })
                  end
****0             return entry, is_dir
              end
          end

****0     return treeiter(iterstack) -- tail-call to try next
      end


      --- return an iterator over all entries in a directory tree
      -- @string d a directory
      -- @return an iterator giving pathname and mode (true for dir, false otherwise)
      -- @raise d must be a non-empty string
    1 function dir.dirtree( d )
****0     assert( d and d ~= "", "directory parameter is missing or empty" )

****0     local last = sub ( d, -1 )
****0     if last == sep or last == '/' then
****0         d = sub( d, 1, -2 )
          end

****0     local iterstack = { {d, ldir(d)} }

****0     return treeiter, iterstack
      end


      --- Recursively returns all the file starting at 'path'. It can optionally take a shell pattern and
      -- only returns files that match 'shell_pattern'. If a pattern is given it will do a case insensitive search.
      -- @string[opt='.'] start_path  A directory.
      -- @string[opt='*'] shell_pattern A shell pattern (see `fnmatch`).
      -- @treturn List(string) containing all the files found recursively starting at 'path' and filtered by 'shell_pattern'.
      -- @raise start_path must be a directory
    1 function dir.getallfiles( start_path, shell_pattern )
****0     start_path = start_path or '.'
****0     assert_dir(1,start_path)
****0     shell_pattern = shell_pattern or "*"

****0     local files = {}
****0     local normcase = path.normcase
****0     for filename, mode in dir.dirtree( start_path ) do
****0         if not mode then
****0             local mask = filemask( shell_pattern )
****0             if normcase(filename):find( mask ) then
****0                 files[#files + 1] = filename
                  end
              end
          end

****0     return makelist(files)
      end

    1 return dir

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/pl/path.lua
==============================================================================
      --- Path manipulation and file queries.
      --
      -- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
      --
      -- NOTE: the functions assume the paths being dealt with to originate
      -- from the OS the application is running on. Windows drive letters are not
      -- to be used when running on a Unix system for example. The one exception
      -- is Windows paths to allow both forward and backward slashes (since Lua
      -- also accepts those)
      --
      -- Dependencies: `pl.utils`, `lfs`
      -- @module pl.path

      -- imports and locals
****0 local _G = _G
****0 local sub = string.sub
****0 local getenv = os.getenv
****0 local tmpnam = os.tmpname
****0 local package = package
****0 local append, concat, remove = table.insert, table.concat, table.remove
****0 local utils = require 'pl.utils'
****0 local assert_string,raise = utils.assert_string,utils.raise

****0 local res,lfs = _G.pcall(_G.require,'lfs')
****0 if not res then
****0     error("pl.path requires LuaFileSystem")
      end

****0 local attrib = lfs.attributes
****0 local currentdir = lfs.currentdir
****0 local link_attrib = lfs.symlinkattributes

****0 local path = {}

      local function err_func(name, param, err, code)
****0   local ret = ("%s failed"):format(tostring(name))
****0   if param ~= nil then
****0     ret = ret .. (" for '%s'"):format(tostring(param))
        end
****0   ret = ret .. (": %s"):format(tostring(err))
****0   if code ~= nil then
****0     ret = ret .. (" (code %s)"):format(tostring(code))
        end
****0   return ret
      end

      --- Lua iterator over the entries of a given directory.
      -- Implicit link to [`luafilesystem.dir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function dir
****0 path.dir = lfs.dir

      --- Creates a directory.
      -- Implicit link to [`luafilesystem.mkdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function mkdir
      path.mkdir = function(d)
****0   local ok, err, code = lfs.mkdir(d)
****0   if not ok then
****0     return ok, err_func("mkdir", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Removes a directory.
      -- Implicit link to [`luafilesystem.rmdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function rmdir
      path.rmdir = function(d)
****0   local ok, err, code = lfs.rmdir(d)
****0   if not ok then
****0     return ok, err_func("rmdir", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Gets attributes.
      -- Implicit link to [`luafilesystem.attributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function attrib
      path.attrib = function(d, r)
****0   local ok, err, code = attrib(d, r)
****0   if not ok then
****0     return ok, err_func("attrib", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Get the working directory.
      -- Implicit link to [`luafilesystem.currentdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function currentdir
      path.currentdir = function()
****0   local ok, err, code = currentdir()
****0   if not ok then
****0     return ok, err_func("currentdir", nil, err, code), code
        end
****0   return ok, err, code
      end

      --- Gets symlink attributes.
      -- Implicit link to [`luafilesystem.symlinkattributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function link_attrib
      path.link_attrib = function(d, r)
****0   local ok, err, code = link_attrib(d, r)
****0   if not ok then
****0     return ok, err_func("link_attrib", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Changes the working directory.
      -- On Windows, if a drive is specified, it also changes the current drive. If
      -- only specifying the drive, it will only switch drive, but not modify the path.
      -- Implicit link to [`luafilesystem.chdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function chdir
      path.chdir = function(d)
****0   local ok, err, code = lfs.chdir(d)
****0   if not ok then
****0     return ok, err_func("chdir", d, err, code), code
        end
****0   return ok, err, code
      end

      --- is this a directory?
      -- @string P A file path
****0 function path.isdir(P)
****0     assert_string(1,P)
****0     return attrib(P,'mode') == 'directory'
      end

      --- is this a file?
      -- @string P A file path
****0 function path.isfile(P)
    1     assert_string(1,P)
    1     return attrib(P,'mode') == 'file'
      end

      -- is this a symbolic link?
      -- @string P A file path
****0 function path.islink(P)
****0     assert_string(1,P)
****0     if link_attrib then
****0         return link_attrib(P,'mode')=='link'
          else
****0         return false
          end
      end

      --- return size of a file.
      -- @string P A file path
****0 function path.getsize(P)
****0     assert_string(1,P)
****0     return attrib(P,'size')
      end

      --- does a path exist?
      -- @string P A file path
      -- @return the file path if it exists (either as file, directory, socket, etc), nil otherwise
****0 function path.exists(P)
****0     assert_string(1,P)
****0     return attrib(P,'mode') ~= nil and P
      end

      --- Return the time of last access as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getatime(P)
****0     assert_string(1,P)
****0     return attrib(P,'access')
      end

      --- Return the time of last modification as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getmtime(P)
****0     assert_string(1,P)
****0     return attrib(P,'modification')
      end

      ---Return the system's ctime as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getctime(P)
****0     assert_string(1,P)
****0     return path.attrib(P,'change')
      end


      local function at(s,i)
  772     return sub(s,i,i)
      end

****0 path.is_windows = utils.is_windows

      local sep, other_sep, seps
      -- constant sep is the directory separator for this platform.
      -- constant dirsep is the separator in the PATH environment variable
****0 if path.is_windows then
****0     path.sep = '\\'; other_sep = '/'
****0     path.dirsep = ';'
****0     seps = { ['/'] = true, ['\\'] = true }
      else
****0     path.sep = '/'
****0     path.dirsep = ':'
****0     seps = { ['/'] = true }
      end
****0 sep = path.sep

      --- are we running Windows?
      -- @class field
      -- @name path.is_windows

      --- path separator for this platform.
      -- @class field
      -- @name path.sep

      --- separator for PATH for this platform
      -- @class field
      -- @name path.dirsep

      --- given a path, return the directory part and a file part.
      -- if there's no directory part, the first value will be empty
      -- @string P A file path
      -- @return directory part
      -- @return file part
      -- @usage
      -- local dir, file = path.splitpath("some/dir/myfile.txt")
      -- assert(dir == "some/dir")
      -- assert(file == "myfile.txt")
      --
      -- local dir, file = path.splitpath("some/dir/")
      -- assert(dir == "some/dir")
      -- assert(file == "")
      --
      -- local dir, file = path.splitpath("some_dir")
      -- assert(dir == "")
      -- assert(file == "some_dir")
****0 function path.splitpath(P)
   52     assert_string(1,P)
   52     local i = #P
   52     local ch = at(P,i)
  768     while i > 0 and ch ~= sep and ch ~= other_sep do
  716         i = i - 1
  716         ch = at(P,i)
          end
   52     if i == 0 then
****0         return '',P
          else
   52         return sub(P,1,i-1), sub(P,i+1)
          end
      end

      --- return an absolute path.
      -- @string P A file path
      -- @string[opt] pwd optional start path to use (default is current dir)
****0 function path.abspath(P,pwd)
****0     assert_string(1,P)
****0     if pwd then assert_string(2,pwd) end
****0     local use_pwd = pwd ~= nil
****0     if not use_pwd and not currentdir() then return P end
****0     P = P:gsub('[\\/]$','')
****0     pwd = pwd or currentdir()
****0     if not path.isabs(P) then
****0         P = path.join(pwd,P)
****0     elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
****0         P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
          end
****0     return path.normpath(P)
      end

      --- given a path, return the root part and the extension part.
      -- if there's no extension part, the second value will be empty
      -- @string P A file path
      -- @treturn string root part (everything upto the "."", maybe empty)
      -- @treturn string extension part (including the ".", maybe empty)
      -- @usage
      -- local file_path, ext = path.splitext("/bonzo/dog_stuff/cat.txt")
      -- assert(file_path == "/bonzo/dog_stuff/cat")
      -- assert(ext == ".txt")
      --
      -- local file_path, ext = path.splitext("")
      -- assert(file_path == "")
      -- assert(ext == "")
****0 function path.splitext(P)
    1     assert_string(1,P)
    1     local i = #P
    1     local ch = at(P,i)
    4     while i > 0 and ch ~= '.' do
    3         if seps[ch] then
****0             return P,''
              end
    3         i = i - 1
    3         ch = at(P,i)
          end
    1     if i == 0 then
****0         return P,''
          else
    1         return sub(P,1,i-1),sub(P,i)
          end
      end

      --- return the directory part of a path
      -- @string P A file path
      -- @treturn string everything before the last dir-separator
      -- @see splitpath
      -- @usage
      -- path.dirname("/some/path/file.txt")   -- "/some/path"
      -- path.dirname("file.txt")              -- "" (empty string)
****0 function path.dirname(P)
   52     assert_string(1,P)
   52     local p1 = path.splitpath(P)
   52     return p1
      end

      --- return the file part of a path
      -- @string P A file path
      -- @treturn string
      -- @see splitpath
      -- @usage
      -- path.basename("/some/path/file.txt")  -- "file.txt"
      -- path.basename("/some/path/file/")     -- "" (empty string)
****0 function path.basename(P)
****0     assert_string(1,P)
****0     local _,p2 = path.splitpath(P)
****0     return p2
      end

      --- get the extension part of a path.
      -- @string P A file path
      -- @treturn string
      -- @see splitext
      -- @usage
      -- path.extension("/some/path/file.txt") -- ".txt"
      -- path.extension("/some/path/file_txt") -- "" (empty string)
****0 function path.extension(P)
    1     assert_string(1,P)
    1     local _,p2 = path.splitext(P)
    1     return p2
      end

      --- is this an absolute path?
      -- @string P A file path
      -- @usage
      -- path.isabs("hello/path")    -- false
      -- path.isabs("/hello/path")   -- true
      -- -- Windows;
      -- path.isabs("hello\path")    -- false
      -- path.isabs("\hello\path")   -- true
      -- path.isabs("C:\hello\path") -- true
      -- path.isabs("C:hello\path")  -- false
****0 function path.isabs(P)
****0     assert_string(1,P)
****0     if path.is_windows and at(P,2) == ":" then
****0         return seps[at(P,3)] ~= nil
          end
****0     return seps[at(P,1)] ~= nil
      end

      --- return the path resulting from combining the individual paths.
      -- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
      -- empty elements (except the last) will be ignored.
      -- @string p1 A file path
      -- @string p2 A file path
      -- @string ... more file paths
      -- @treturn string the combined path
      -- @usage
      -- path.join("/first","second","third")   -- "/first/second/third"
      -- path.join("first","second/third")      -- "first/second/third"
      -- path.join("/first","/second","third")  -- "/second/third"
****0 function path.join(p1,p2,...)
****0     assert_string(1,p1)
****0     assert_string(2,p2)
****0     if select('#',...) > 0 then
****0         local p = path.join(p1,p2)
****0         local args = {...}
****0         for i = 1,#args do
****0             assert_string(i,args[i])
****0             p = path.join(p,args[i])
              end
****0         return p
          end
****0     if path.isabs(p2) then return p2 end
****0     local endc = at(p1,#p1)
****0     if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
****0         p1 = p1..path.sep
          end
****0     return p1..p2
      end

      --- normalize the case of a pathname. On Unix, this returns the path unchanged,
      -- for Windows it converts;
      --
      -- * the path to lowercase
      -- * forward slashes to backward slashes
      -- @string P A file path
      -- @usage path.normcase("/Some/Path/File.txt")
      -- -- Windows: "\some\path\file.txt"
      -- -- Others : "/Some/Path/File.txt"
****0 function path.normcase(P)
****0     assert_string(1,P)
****0     if path.is_windows then
****0         return P:gsub('/','\\'):lower()
          else
****0         return P
          end
      end

      --- normalize a path name.
      -- `A//B`, `A/./B`, and `A/foo/../B` all become `A/B`.
      --
      -- An empty path results in '.'.
      -- @string P a file path
****0 function path.normpath(P)
****0     assert_string(1,P)
          -- Split path into anchor and relative path.
****0     local anchor = ''
****0     if path.is_windows then
****0         if P:match '^\\\\' then -- UNC
****0             anchor = '\\\\'
****0             P = P:sub(3)
****0         elseif seps[at(P, 1)] then
****0             anchor = '\\'
****0             P = P:sub(2)
****0         elseif at(P, 2) == ':' then
****0             anchor = P:sub(1, 2)
****0             P = P:sub(3)
****0             if seps[at(P, 1)] then
****0                 anchor = anchor..'\\'
****0                 P = P:sub(2)
                  end
              end
****0         P = P:gsub('/','\\')
          else
              -- According to POSIX, in path start '//' and '/' are distinct,
              -- but '///+' is equivalent to '/'.
****0         if P:match '^//' and at(P, 3) ~= '/' then
****0             anchor = '//'
****0             P = P:sub(3)
****0         elseif at(P, 1) == '/' then
****0             anchor = '/'
****0             P = P:match '^/*(.*)$'
              end
          end
****0     local parts = {}
****0     for part in P:gmatch('[^'..sep..']+') do
****0         if part == '..' then
****0             if #parts ~= 0 and parts[#parts] ~= '..' then
****0                 remove(parts)
                  else
****0                 append(parts, part)
                  end
****0         elseif part ~= '.' then
****0             append(parts, part)
              end
          end
****0     P = anchor..concat(parts, sep)
****0     if P == '' then P = '.' end
****0     return P
      end

      --- relative path from current directory or optional start point
      -- @string P a path
      -- @string[opt] start optional start point (default current directory)
****0 function path.relpath (P,start)
****0     assert_string(1,P)
****0     if start then assert_string(2,start) end
****0     local split,min,append = utils.split, math.min, table.insert
****0     P = path.abspath(P,start)
****0     start = start or currentdir()
          local compare
****0     if path.is_windows then
****0         P = P:gsub("/","\\")
****0         start = start:gsub("/","\\")
****0         compare = function(v) return v:lower() end
          else
****0         compare = function(v) return v end
          end
****0     local startl, Pl = split(start,sep), split(P,sep)
****0     local n = min(#startl,#Pl)
****0     if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then
****0         return P
          end
****0     local k = n+1 -- default value if this loop doesn't bail out!
****0     for i = 1,n do
****0         if compare(startl[i]) ~= compare(Pl[i]) then
****0             k = i
                  break
              end
          end
****0     local rell = {}
****0     for i = 1, #startl-k+1 do rell[i] = '..' end
****0     if k <= #Pl then
****0         for i = k,#Pl do append(rell,Pl[i]) end
          end
****0     return table.concat(rell,sep)
      end


      --- Replace a starting '~' with the user's home directory.
      -- In windows, if HOME isn't set, then USERPROFILE is used in preference to
      -- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
      -- @string P A file path
      -- @treturn[1] string The file path with the `~` prefix substituted, or the input path if it had no prefix.
      -- @treturn[2] nil
      -- @treturn[2] string Error message if the environment variables were unavailable.
****0 function path.expanduser(P)
****0     assert_string(1,P)
****0     if P:sub(1,1) ~= '~' then
****0         return P
          end

****0     local home = getenv('HOME')
****0     if (not home) and (not path.is_windows) then
              -- no more options to try on Nix
****0         return nil, "failed to expand '~' (HOME not set)"
          end

****0     if (not home) then
              -- try alternatives on Windows
****0         home = getenv 'USERPROFILE'
****0         if not home then
****0             local hd = getenv 'HOMEDRIVE'
****0             local hp = getenv 'HOMEPATH'
****0             if not (hd and hp) then
****0               return nil, "failed to expand '~' (HOME, USERPROFILE, and HOMEDRIVE and/or HOMEPATH not set)"
                  end
****0             home = hd..hp
              end
          end

****0     return home..sub(P,2)
      end


      ---Return a suitable full path to a new temporary file name.
      -- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)
****0 function path.tmpname ()
****0     local res = tmpnam()
          -- On Windows if Lua is compiled using MSVC14 os.tmpname
          -- already returns an absolute path within TEMP env variable directory,
          -- no need to prepend it.
****0     if path.is_windows and not res:find(':') then
****0         res = getenv('TEMP')..res
          end
****0     return res
      end

      --- return the largest common prefix path of two paths.
      -- @string path1 a file path
      -- @string path2 a file path
      -- @return the common prefix (Windows: separators will be normalized, casing will be original)
****0 function path.common_prefix (path1,path2)
****0     assert_string(1,path1)
****0     assert_string(2,path2)
          -- get them in order!
****0     if #path1 > #path2 then path2,path1 = path1,path2 end
          local compare
****0     if path.is_windows then
****0         path1 = path1:gsub("/", "\\")
****0         path2 = path2:gsub("/", "\\")
****0         compare = function(v) return v:lower() end
          else
****0         compare = function(v) return v end
          end
****0     for i = 1,#path1 do
****0         if compare(at(path1,i)) ~= compare(at(path2,i)) then
****0             local cp = path1:sub(1,i-1)
****0             if at(path1,i-1) ~= sep then
****0                 cp = path.dirname(cp)
                  end
****0             return cp
              end
          end
****0     if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
****0     return path1
          --return ''
      end

      --- return the full path where a particular Lua module would be found.
      -- Both package.path and package.cpath is searched, so the result may
      -- either be a Lua file or a shared library.
      -- @string mod name of the module
      -- @return on success: path of module, lua or binary
      -- @return on error: nil, error string listing paths tried
****0 function path.package_path(mod)
****0     assert_string(1,mod)
          local res, err1, err2
****0     res, err1 = package.searchpath(mod,package.path)
****0     if res then return res,true end
****0     res, err2 = package.searchpath(mod,package.cpath)
****0     if res then return res,false end
****0     return raise ('cannot find module on path\n' .. err1 .. "\n" .. err2)
      end


      ---- finis -----
****0 return path

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/pl/tablex.lua
==============================================================================
      --- Extended operations on Lua tables.
      --
      -- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
      --
      -- Dependencies: `pl.utils`, `pl.types`
      -- @module pl.tablex
****0 local utils = require ('pl.utils')
****0 local types = require ('pl.types')
****0 local getmetatable,setmetatable,require = getmetatable,setmetatable,require
****0 local tsort,append,remove = table.sort,table.insert,table.remove
****0 local min = math.min
****0 local pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring
****0 local function_arg = utils.function_arg
****0 local assert_arg = utils.assert_arg

****0 local tablex = {}

      -- generally, functions that make copies of tables try to preserve the metatable.
      -- However, when the source has no obvious type, then we attach appropriate metatables
      -- like List, Map, etc to the result.
      local function setmeta (res,tbl,pl_class)
****0     local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)
****0     return mt and setmetatable(res, mt) or res
      end

      local function makelist(l)
****0     return setmetatable(l, require('pl.List'))
      end

      local function makemap(m)
****0     return setmetatable(m, require('pl.Map'))
      end

      local function complain (idx,msg)
****0     error(('argument %d is not %s'):format(idx,msg),3)
      end

      local function assert_arg_indexable (idx,val)
****0     if not types.is_indexable(val) then
****0         complain(idx,"indexable")
          end
      end

      local function assert_arg_iterable (idx,val)
    2     if not types.is_iterable(val) then
****0         complain(idx,"iterable")
          end
      end

      local function assert_arg_writeable (idx,val)
****0     if not types.is_writeable(val) then
****0         complain(idx,"writeable")
          end
      end

      --- copy a table into another, in-place.
      -- @within Copying
      -- @tab t1 destination table
      -- @tab t2 source (actually any iterable object)
      -- @return first table
****0 function tablex.update (t1,t2)
****0     assert_arg_writeable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     for k,v in pairs(t2) do
****0         t1[k] = v
          end
****0     return t1
      end

      --- total number of elements in this table.
      -- Note that this is distinct from `#t`, which is the number
      -- of values in the array part; this value will always
      -- be greater or equal. The difference gives the size of
      -- the hash part, for practical purposes. Works for any
      -- object with a __pairs metamethod.
      -- @tab t a table
      -- @return the size
****0 function tablex.size (t)
****0     assert_arg_iterable(1,t)
****0     local i = 0
****0     for k in pairs(t) do i = i + 1 end
****0     return i
      end

      --- make a shallow copy of a table
      -- @within Copying
      -- @tab t an iterable source
      -- @return new table
****0 function tablex.copy (t)
    2     assert_arg_iterable(1,t)
    2     local res = {}
   93     for k,v in pairs(t) do
   91         res[k] = v
          end
    2     return res
      end

      local function cycle_aware_copy(t, cache)
****0     if type(t) ~= 'table' then return t end
****0     if cache[t] then return cache[t] end
****0     assert_arg_iterable(1,t)
****0     local res = {}
****0     cache[t] = res
****0     local mt = getmetatable(t)
****0     for k,v in pairs(t) do
****0         k = cycle_aware_copy(k, cache)
****0         v = cycle_aware_copy(v, cache)
****0         res[k] = v
          end
****0     setmetatable(res,mt)
****0     return res
      end

      --- make a deep copy of a table, recursively copying all the keys and fields.
      -- This supports cycles in tables; cycles will be reproduced in the copy.
      -- This will also set the copied table's metatable to that of the original.
      -- @within Copying
      -- @tab t A table
      -- @return new table
****0 function tablex.deepcopy(t)
****0     return cycle_aware_copy(t,{})
      end

****0 local abs = math.abs

      local function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)
****0     if cache[t1] and cache[t1][t2] then return true end
****0     local ty1 = type(t1)
****0     local ty2 = type(t2)
****0     if ty1 ~= ty2 then return false end
          -- non-table types can be directly compared
****0     if ty1 ~= 'table' then
****0         if ty1 == 'number' and eps then return abs(t1-t2) < eps end
****0         return t1 == t2
          end
          -- as well as tables which have the metamethod __eq
****0     local mt = getmetatable(t1)
****0     if not ignore_mt and mt and mt.__eq then return t1 == t2 end
****0     for k1 in pairs(t1) do
****0         if t2[k1]==nil then return false end
          end
****0     for k2 in pairs(t2) do
****0         if t1[k2]==nil then return false end
          end
****0     cache[t1] = cache[t1] or {}
****0     cache[t1][t2] = true
****0     for k1,v1 in pairs(t1) do
****0         local v2 = t2[k1]
****0         if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end
          end
****0     return true
      end

      --- compare two values.
      -- if they are tables, then compare their keys and fields recursively.
      -- @within Comparing
      -- @param t1 A value
      -- @param t2 A value
      -- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
      -- @number[opt] eps if defined, then used for any number comparisons
      -- @return true or false
****0 function tablex.deepcompare(t1,t2,ignore_mt,eps)
****0     return cycle_aware_compare(t1,t2,ignore_mt,eps,{})
      end

      --- compare two arrays using a predicate.
      -- @within Comparing
      -- @array t1 an array
      -- @array t2 an array
      -- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`
      -- @return true or false
      -- @usage
      -- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, "=="))
      --
      -- assert(tablex.compare(
      --    {1,2,3, hello = "world"},  -- fields are not compared!
      --    {1,2,3}, function(v1, v2) return v1 == v2 end)
****0 function tablex.compare (t1,t2,cmp)
****0     assert_arg_indexable(1,t1)
****0     assert_arg_indexable(2,t2)
****0     if #t1 ~= #t2 then return false end
****0     cmp = function_arg(3,cmp)
****0     for k = 1,#t1 do
****0         if not cmp(t1[k],t2[k]) then return false end
          end
****0     return true
      end

      --- compare two list-like tables using an optional predicate, without regard for element order.
      -- @within Comparing
      -- @array t1 a list-like table
      -- @array t2 a list-like table
      -- @param cmp A comparison function (may be nil)
****0 function tablex.compare_no_order (t1,t2,cmp)
****0     assert_arg_indexable(1,t1)
****0     assert_arg_indexable(2,t2)
****0     if cmp then cmp = function_arg(3,cmp) end
****0     if #t1 ~= #t2 then return false end
****0     local visited = {}
****0     for i = 1,#t1 do
****0         local val = t1[i]
              local gotcha
****0         for j = 1,#t2 do
****0             if not visited[j] then
                      local match
****0                 if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
****0                 if match then
****0                     gotcha = j
                          break
                      end
                  end
              end
****0         if not gotcha then return false end
****0         visited[gotcha] = true
          end
****0     return true
      end


      --- return the index of a value in a list.
      -- Like string.find, there is an optional index to start searching,
      -- which can be negative.
      -- @within Finding
      -- @array t A list-like table
      -- @param val A value
      -- @int idx index to start; -1 means last element,etc (default 1)
      -- @return index of value or nil if not found
      -- @usage find({10,20,30},20) == 2
      -- @usage find({'a','b','a','c'},'a',2) == 3
****0 function tablex.find(t,val,idx)
****0     assert_arg_indexable(1,t)
****0     idx = idx or 1
****0     if idx < 0 then idx = #t + idx + 1 end
****0     for i = idx,#t do
****0         if t[i] == val then return i end
          end
****0     return nil
      end

      --- return the index of a value in a list, searching from the end.
      -- Like string.find, there is an optional index to start searching,
      -- which can be negative.
      -- @within Finding
      -- @array t A list-like table
      -- @param val A value
      -- @param idx index to start; -1 means last element,etc (default `#t`)
      -- @return index of value or nil if not found
      -- @usage rfind({10,10,10},10) == 3
****0 function tablex.rfind(t,val,idx)
****0     assert_arg_indexable(1,t)
****0     idx = idx or #t
****0     if idx < 0 then idx = #t + idx + 1 end
****0     for i = idx,1,-1 do
****0         if t[i] == val then return i end
          end
****0     return nil
      end


      --- return the index (or key) of a value in a table using a comparison function.
      --
      -- *NOTE*: the 2nd return value of this function, the value returned
      -- by the comparison function, has a limitation that it cannot be `false`.
      -- Because if it is, then it indicates the comparison failed, and the
      -- function will continue the search. See examples.
      -- @within Finding
      -- @tab t A table
      -- @func cmp A comparison function
      -- @param arg an optional second argument to the function
      -- @return index of value, or nil if not found
      -- @return value returned by comparison function (cannot be `false`!)
      -- @usage
      -- -- using an operator
      -- local lst = { "Rudolph", true, false, 15 }
      -- local idx, cmp_result = tablex.rfind(lst, "==", "Rudolph")
      -- assert(idx == 1)
      -- assert(cmp_result == true)
      --
      -- local idx, cmp_result = tablex.rfind(lst, "==", false)
      -- assert(idx == 3)
      -- assert(cmp_result == true)       -- looking up 'false' works!
      --
      -- -- using a function returning the value looked up
      -- local cmp = function(v1, v2) return v1 == v2 and v2 end
      -- local idx, cmp_result = tablex.rfind(lst, cmp, "Rudolph")
      -- assert(idx == 1)
      -- assert(cmp_result == "Rudolph")  -- the value is returned
      --
      -- -- NOTE: this fails, since 'false' cannot be returned!
      -- local idx, cmp_result = tablex.rfind(lst, cmp, false)
      -- assert(idx == nil)               -- looking up 'false' failed!
      -- assert(cmp_result == nil)
****0 function tablex.find_if(t,cmp,arg)
****0     assert_arg_iterable(1,t)
****0     cmp = function_arg(2,cmp)
****0     for k,v in pairs(t) do
****0         local c = cmp(v,arg)
****0         if c then return k,c end
          end
****0     return nil
      end

      --- return a list of all values in a table indexed by another list.
      -- @tab tbl a table
      -- @array idx an index table (a list of keys)
      -- @return a list-like table
      -- @usage index_by({10,20,30,40},{2,4}) == {20,40}
      -- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
****0 function tablex.index_by(tbl,idx)
****0     assert_arg_indexable(1,tbl)
****0     assert_arg_indexable(2,idx)
****0     local res = {}
****0     for i = 1,#idx do
****0         res[i] = tbl[idx[i]]
          end
****0     return setmeta(res,tbl,'List')
      end

      --- apply a function to all values of a table.
      -- This returns a table of the results.
      -- Any extra arguments are passed to the function.
      -- @within MappingAndFiltering
      -- @func fun A function that takes at least one argument
      -- @tab t A table
      -- @param ... optional arguments
      -- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
****0 function tablex.map(fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t) do
****0         res[k] = fun(v,...)
          end
****0     return setmeta(res,t)
      end

      --- apply a function to all values of a list.
      -- This returns a table of the results.
      -- Any extra arguments are passed to the function.
      -- @within MappingAndFiltering
      -- @func fun A function that takes at least one argument
      -- @array t a table (applies to array part)
      -- @param ... optional arguments
      -- @return a list-like table
      -- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
****0 function tablex.imap(fun,t,...)
****0     assert_arg_indexable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for i = 1,#t do
****0         res[i] = fun(t[i],...) or false
          end
****0     return setmeta(res,t,'List')
      end

      --- apply a named method to values from a table.
      -- @within MappingAndFiltering
      -- @string name the method name
      -- @array t a list-like table
      -- @param ... any extra arguments to the method
      -- @return a `List` with the results of the method (1st result only)
      -- @usage
      -- local Car = {}
      -- Car.__index = Car
      -- function Car.new(car)
      --   return setmetatable(car or {}, Car)
      -- end
      -- Car.speed = 0
      -- function Car:faster(increase)
      --   self.speed = self.speed + increase
      --   return self.speed
      -- end
      --
      -- local ferrari = Car.new{ name = "Ferrari" }
      -- local lamborghini = Car.new{ name = "Lamborghini", speed = 50 }
      -- local cars = { ferrari, lamborghini }
      --
      -- assert(ferrari.speed == 0)
      -- assert(lamborghini.speed == 50)
      -- tablex.map_named_method("faster", cars, 10)
      -- assert(ferrari.speed == 10)
      -- assert(lamborghini.speed == 60)
****0 function tablex.map_named_method (name,t,...)
****0     utils.assert_string(1,name)
****0     assert_arg_indexable(2,t)
****0     local res = {}
****0     for i = 1,#t do
****0         local val = t[i]
****0         local fun = val[name]
****0         res[i] = fun(val,...)
          end
****0     return setmeta(res,t,'List')
      end

      --- apply a function to all values of a table, in-place.
      -- Any extra arguments are passed to the function.
      -- @func fun A function that takes at least one argument
      -- @tab t a table
      -- @param ... extra arguments passed to `fun`
      -- @see tablex.foreach
****0 function tablex.transform (fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     for k,v in pairs(t) do
****0         t[k] = fun(v,...)
          end
      end

      --- generate a table of all numbers in a range.
      -- This is consistent with a numerical for loop.
      -- @int start  number
      -- @int finish number
      -- @int[opt=1] step  make this negative for start < finish
****0 function tablex.range (start,finish,step)
          local res
****0     step = step or 1
****0     if start == finish then
****0         res = {start}
****0     elseif (start > finish and step > 0) or (finish > start and step < 0) then
****0         res = {}
          else
****0         local k = 1
****0         res = {}
****0         for i=start,finish,step do res[k]=i; k=k+1 end
          end
****0     return makelist(res)
      end

      --- apply a function to values from two tables.
      -- @within MappingAndFiltering
      -- @func fun a function of at least two arguments
      -- @tab t1 a table
      -- @tab t2 a table
      -- @param ... extra arguments
      -- @return a table
      -- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
****0 function tablex.map2 (fun,t1,t2,...)
****0     assert_arg_iterable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t1) do
****0         res[k] = fun(v,t2[k],...)
          end
****0     return setmeta(res,t1,'List')
      end

      --- apply a function to values from two arrays.
      -- The result will be the length of the shortest array.
      -- @within MappingAndFiltering
      -- @func fun a function of at least two arguments
      -- @array t1 a list-like table
      -- @array t2 a list-like table
      -- @param ... extra arguments
      -- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
****0 function tablex.imap2 (fun,t1,t2,...)
****0     assert_arg_indexable(2,t1)
****0     assert_arg_indexable(3,t2)
****0     fun = function_arg(1,fun)
****0     local res,n = {},math.min(#t1,#t2)
****0     for i = 1,n do
****0         res[i] = fun(t1[i],t2[i],...)
          end
****0     return res
      end

      --- 'reduce' a list using a binary function.
      -- @func fun a function of two arguments
      -- @array t a list-like table
      -- @array memo optional initial memo value. Defaults to first value in table.
      -- @return the result of the function
      -- @usage reduce('+',{1,2,3,4}) == 10
****0 function tablex.reduce (fun,t,memo)
****0     assert_arg_indexable(2,t)
****0     fun = function_arg(1,fun)
****0     local n = #t
****0     if n == 0 then
****0         return memo
          end
****0     local res = memo and fun(memo, t[1]) or t[1]
****0     for i = 2,n do
****0         res = fun(res,t[i])
          end
****0     return res
      end

      --- apply a function to all elements of a table.
      -- The arguments to the function will be the value,
      -- the key and _finally_ any extra arguments passed to this function.
      -- Note that the Lua 5.0 function table.foreach passed the _key_ first.
      -- @within Iterating
      -- @tab t a table
      -- @func fun a function on the elements; `function(value, key, ...)`
      -- @param ... extra arguments passed to `fun`
      -- @see tablex.transform
****0 function tablex.foreach(t,fun,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(2,fun)
****0     for k,v in pairs(t) do
****0         fun(v,k,...)
          end
      end

      --- apply a function to all elements of a list-like table in order.
      -- The arguments to the function will be the value,
      -- the index and _finally_ any extra arguments passed to this function
      -- @within Iterating
      -- @array t a table
      -- @func fun a function with at least one argument
      -- @param ... optional arguments
****0 function tablex.foreachi(t,fun,...)
****0     assert_arg_indexable(1,t)
****0     fun = function_arg(2,fun)
****0     for i = 1,#t do
****0         fun(t[i],i,...)
          end
      end

      --- Apply a function to a number of tables.
      -- A more general version of map
      -- The result is a table containing the result of applying that function to the
      -- ith value of each table. Length of output list is the minimum length of all the lists
      -- @within MappingAndFiltering
      -- @func fun a function of n arguments
      -- @tab ... n tables
      -- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
      -- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}
      -- @param fun A function that takes as many arguments as there are tables
****0 function tablex.mapn(fun,...)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     local lists = {...}
****0     local minn = 1e40
****0     for i = 1,#lists do
****0         minn = min(minn,#(lists[i]))
          end
****0     for i = 1,minn do
****0         local args,k = {},1
****0         for j = 1,#lists do
****0             args[k] = lists[j][i]
****0             k = k + 1
              end
****0         res[#res+1] = fun(unpack(args))
          end
****0     return res
      end

      --- call the function with the key and value pairs from a table.
      -- The function can return a value and a key (note the order!). If both
      -- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that
      -- key into a table and append into it. If only value is not nil, then it is appended to the result.
      -- @within MappingAndFiltering
      -- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
      -- @tab t A table
      -- @param ... optional arguments
      -- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
      -- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
****0 function tablex.pairmap(fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t) do
****0         local rv,rk = fun(k,v,...)
****0         if rk then
****0             if res[rk] then
****0                 if type(res[rk]) == 'table' then
****0                     table.insert(res[rk],rv)
                      else
****0                     res[rk] = {res[rk], rv}
                      end
                  else
****0                 res[rk] = rv
                  end
              else
****0             res[#res+1] = rv
              end
          end
****0     return res
      end

****0 local function keys_op(i,v) return i end

      --- return all the keys of a table in arbitrary order.
      -- @within Extraction
      -- @tab t A list-like table where the values are the keys of the input table
****0 function tablex.keys(t)
****0     assert_arg_iterable(1,t)
****0     return makelist(tablex.pairmap(keys_op,t))
      end

****0 local function values_op(i,v) return v end

      --- return all the values of the table in arbitrary order
      -- @within Extraction
      -- @tab t A list-like table where the values are the values of the input table
****0 function tablex.values(t)
****0     assert_arg_iterable(1,t)
****0     return makelist(tablex.pairmap(values_op,t))
      end

****0 local function index_map_op (i,v) return i,v end

      --- create an index map from a list-like table. The original values become keys,
      -- and the associated values are the indices into the original list.
      -- @array t a list-like table
      -- @return a map-like table
****0 function tablex.index_map (t)
****0     assert_arg_indexable(1,t)
****0     return makemap(tablex.pairmap(index_map_op,t))
      end

****0 local function set_op(i,v) return true,v end

      --- create a set from a list-like table. A set is a table where the original values
      -- become keys, and the associated values are all true.
      -- @array t a list-like table
      -- @return a set (a map-like table)
****0 function tablex.makeset (t)
****0     assert_arg_indexable(1,t)
****0     return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))
      end

      --- combine two tables, either as union or intersection. Corresponds to
      -- set operations for sets () but more general. Not particularly
      -- useful for list-like tables.
      -- @within Merging
      -- @tab t1 a table
      -- @tab t2 a table
      -- @bool dup true for a union, false for an intersection.
      -- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
      -- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
      -- @see tablex.index_map
****0 function tablex.merge (t1,t2,dup)
****0     assert_arg_iterable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     local res = {}
****0     for k,v in pairs(t1) do
****0         if dup or t2[k] then res[k] = v end
          end
****0     if dup then
****0       for k,v in pairs(t2) do
****0         res[k] = v
            end
          end
****0     return setmeta(res,t1,'Map')
      end

      --- the union of two map-like tables.
      -- If there are duplicate keys, the second table wins.
      -- @tab t1 a table
      -- @tab t2 a table
      -- @treturn tab
      -- @see tablex.merge
****0 function tablex.union(t1, t2)
****0     return tablex.merge(t1, t2, true)
      end

      --- the intersection of two map-like tables.
      -- @tab t1 a table
      -- @tab t2 a table
      -- @treturn tab
      -- @see tablex.merge
****0 function tablex.intersection(t1, t2)
****0     return tablex.merge(t1, t2, false)
      end

      --- a new table which is the difference of two tables.
      -- With sets (where the values are all true) this is set difference and
      -- symmetric difference depending on the third parameter.
      -- @within Merging
      -- @tab s1 a map-like table or set
      -- @tab s2 a map-like table or set
      -- @bool symm symmetric difference (default false)
      -- @return a map-like table or set
****0 function tablex.difference (s1,s2,symm)
****0     assert_arg_iterable(1,s1)
****0     assert_arg_iterable(2,s2)
****0     local res = {}
****0     for k,v in pairs(s1) do
****0         if s2[k] == nil then res[k] = v end
          end
****0     if symm then
****0         for k,v in pairs(s2) do
****0             if s1[k] == nil then res[k] = v end
              end
          end
****0     return setmeta(res,s1,'Map')
      end

      --- A table where the key/values are the values and value counts of the table.
      -- @array t a list-like table
      -- @func cmp a function that defines equality (otherwise uses ==)
      -- @return a map-like table
      -- @see seq.count_map
****0 function tablex.count_map (t,cmp)
****0     assert_arg_indexable(1,t)
****0     local res,mask = {},{}
****0     cmp = function_arg(2,cmp or '==')
****0     local n = #t
****0     for i = 1,#t do
****0         local v = t[i]
****0         if not mask[v] then
****0             mask[v] = true
                  -- check this value against all other values
****0             res[v] = 1  -- there's at least one instance
****0             for j = i+1,n do
****0                 local w = t[j]
****0                 local ok = cmp(v,w)
****0                 if ok then
****0                     res[v] = res[v] + 1
****0                     mask[w] = true
                      end
                  end
              end
          end
****0     return makemap(res)
      end

      --- filter an array's values using a predicate function
      -- @within MappingAndFiltering
      -- @array t a list-like table
      -- @func pred a boolean function
      -- @param arg optional argument to be passed as second argument of the predicate
****0 function tablex.filter (t,pred,arg)
****0     assert_arg_indexable(1,t)
****0     pred = function_arg(2,pred)
****0     local res,k = {},1
****0     for i = 1,#t do
****0         local v = t[i]
****0         if pred(v,arg) then
****0             res[k] = v
****0             k = k + 1
              end
          end
****0     return setmeta(res,t,'List')
      end

      --- return a table where each element is a table of the ith values of an arbitrary
      -- number of tables. It is equivalent to a matrix transpose.
      -- @within Merging
      -- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
      -- @array ... arrays to be zipped
****0 function tablex.zip(...)
****0     return tablex.mapn(function(...) return {...} end,...)
      end

      local _copy
****0 function _copy (dest,src,idest,isrc,nsrc,clean_tail)
****0     idest = idest or 1
****0     isrc = isrc or 1
          local iend
****0     if not nsrc then
****0         nsrc = #src
****0         iend = #src
          else
****0         iend = isrc + min(nsrc-1,#src-isrc)
          end
****0     if dest == src then -- special case
****0         if idest > isrc and iend >= idest then -- overlapping ranges
****0             src = tablex.sub(src,isrc,nsrc)
****0             isrc = 1; iend = #src
              end
          end
****0     for i = isrc,iend do
****0         dest[idest] = src[i]
****0         idest = idest + 1
          end
****0     if clean_tail then
****0         tablex.clear(dest,idest)
          end
****0     return dest
      end

      --- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
      -- @within Copying
      -- @array dest a list-like table
      -- @array src a list-like table
      -- @int[opt=1] idest where to start copying values into destination
      -- @int[opt=1] isrc where to start copying values from source
      -- @int[opt=#src] nsrc number of elements to copy from source
****0 function tablex.icopy (dest,src,idest,isrc,nsrc)
****0     assert_arg_indexable(1,dest)
****0     assert_arg_indexable(2,src)
****0     return _copy(dest,src,idest,isrc,nsrc,true)
      end

      --- copy an array into another one.
      -- @within Copying
      -- @array dest a list-like table
      -- @array src a list-like table
      -- @int[opt=1] idest where to start copying values into destination
      -- @int[opt=1] isrc where to start copying values from source
      -- @int[opt=#src] nsrc number of elements to copy from source
****0 function tablex.move (dest,src,idest,isrc,nsrc)
****0     assert_arg_indexable(1,dest)
****0     assert_arg_indexable(2,src)
****0     return _copy(dest,src,idest,isrc,nsrc,false)
      end

****0 function tablex._normalize_slice(self,first,last)
****0   local sz = #self
****0   if not first then first=1 end
****0   if first<0 then first=sz+first+1 end
        -- make the range _inclusive_!
****0   if not last then last=sz end
****0   if last < 0 then last=sz+1+last end
****0   return first,last
      end

      --- Extract a range from a table, like  'string.sub'.
      -- If first or last are negative then they are relative to the end of the list
      -- eg. sub(t,-2) gives last 2 entries in a list, and
      -- sub(t,-4,-2) gives from -4th to -2nd
      -- @within Extraction
      -- @array t a list-like table
      -- @int first An index
      -- @int last An index
      -- @return a new List
****0 function tablex.sub(t,first,last)
****0     assert_arg_indexable(1,t)
****0     first,last = tablex._normalize_slice(t,first,last)
****0     local res={}
****0     for i=first,last do append(res,t[i]) end
****0     return setmeta(res,t,'List')
      end

      --- set an array range to a value. If it's a function we use the result
      -- of applying it to the indices.
      -- @array t a list-like table
      -- @param val a value
      -- @int[opt=1] i1 start range
      -- @int[opt=#t] i2 end range
****0 function tablex.set (t,val,i1,i2)
****0     assert_arg_indexable(1,t)
****0     i1,i2 = i1 or 1,i2 or #t
****0     if types.is_callable(val) then
****0         for i = i1,i2 do
****0             t[i] = val(i)
              end
          else
****0         for i = i1,i2 do
****0             t[i] = val
              end
          end
      end

      --- create a new array of specified size with initial value.
      -- @int n size
      -- @param val initial value (can be `nil`, but don't expect `#` to work!)
      -- @return the table
****0 function tablex.new (n,val)
****0     local res = {}
****0     tablex.set(res,val,1,n)
****0     return res
      end

      --- clear out the contents of a table.
      -- @array t a list
      -- @param istart optional start position
****0 function tablex.clear(t,istart)
****0     istart = istart or 1
****0     for i = istart,#t do remove(t) end
      end

      --- insert values into a table.
      -- similar to `table.insert` but inserts values from given table `values`,
      -- not the object itself, into table `t` at position `pos`.
      -- @within Copying
      -- @array t the list
      -- @int[opt] position (default is at end)
      -- @array values
****0 function tablex.insertvalues(t, ...)
    1     assert_arg(1,t,'table')
          local pos, values
    1     if select('#', ...) == 1 then
    1         pos,values = #t+1, ...
          else
****0         pos,values = ...
          end
    1     if #values > 0 then
    1         for i=#t,pos,-1 do
****0             t[i+#values] = t[i]
              end
    1         local offset = 1 - pos
    2         for i=pos,pos+#values-1 do
    1             t[i] = values[i + offset]
              end
          end
    1     return t
      end

      --- remove a range of values from a table.
      -- End of range may be negative.
      -- @array t a list-like table
      -- @int i1 start index
      -- @int i2 end index
      -- @return the table
****0 function tablex.removevalues (t,i1,i2)
****0     assert_arg(1,t,'table')
****0     i1,i2 = tablex._normalize_slice(t,i1,i2)
****0     for i = i1,i2 do
****0         remove(t,i1)
          end
****0     return t
      end

      local _find
      _find = function (t,value,tables)
****0     for k,v in pairs(t) do
****0         if v == value then return k end
          end
****0     for k,v in pairs(t) do
****0         if not tables[v] and type(v) == 'table' then
****0             tables[v] = true
****0             local res = _find(v,value,tables)
****0             if res then
****0                 res = tostring(res)
****0                 if type(k) ~= 'string' then
****0                     return '['..k..']'..res
                      else
****0                     return k..'.'..res
                      end
                  end
              end
          end
      end

      --- find a value in a table by recursive search.
      -- @within Finding
      -- @tab t the table
      -- @param value the value
      -- @array[opt] exclude any tables to avoid searching
      -- @return a fieldspec, e.g. 'a.b' or 'math.sin'
      -- @usage search(_G,math.sin,{package.path}) == 'math.sin'
****0 function tablex.search (t,value,exclude)
****0     assert_arg_iterable(1,t)
****0     local tables = {[t]=true}
****0     if exclude then
****0         for _,v in pairs(exclude) do tables[v] = true end
          end
****0     return _find(t,value,tables)
      end

      --- return an iterator to a table sorted by its keys
      -- @within Iterating
      -- @tab t the table
      -- @func f an optional comparison function (f(x,y) is true if x < y)
      -- @usage for k,v in tablex.sort(t) do print(k,v) end
      -- @return an iterator to traverse elements sorted by the keys
****0 function tablex.sort(t,f)
****0     local keys = {}
****0     for k in pairs(t) do keys[#keys + 1] = k end
****0     tsort(keys,f)
****0     local i = 0
          return function()
****0         i = i + 1
****0         return keys[i], t[keys[i]]
          end
      end

      --- return an iterator to a table sorted by its values
      -- @within Iterating
      -- @tab t the table
      -- @func f an optional comparison function (f(x,y) is true if x < y)
      -- @usage for k,v in tablex.sortv(t) do print(k,v) end
      -- @return an iterator to traverse elements sorted by the values
****0 function tablex.sortv(t,f)
****0     f = function_arg(2, f or '<')
****0     local keys = {}
****0     for k in pairs(t) do keys[#keys + 1] = k end
****0     tsort(keys,function(x, y) return f(t[x], t[y]) end)
****0     local i = 0
          return function()
****0         i = i + 1
****0         return keys[i], t[keys[i]]
          end
      end

      --- modifies a table to be read only.
      -- This only offers weak protection. Tables can still be modified with
      -- `table.insert` and `rawset`.
      --
      -- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the
      -- equivalent metamethods are only available in Lua 5.2 and newer.
      -- @tab t the table
      -- @return the table read only (a proxy).
****0 function tablex.readonly(t)
****0     local mt = {
              __index=t,
              __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
              __pairs=function() return pairs(t) end,
              __ipairs=function() return ipairs(t) end,
              __len=function() return #t end,
****0         __metatable=false
          }
****0     return setmetatable({}, mt)
      end

****0 return tablex

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/pl/types.lua
==============================================================================
      ---- Dealing with Detailed Type Information

      -- Dependencies `pl.utils`
      -- @module pl.types

****0 local utils = require 'pl.utils'
****0 local math_ceil = math.ceil
****0 local assert_arg = utils.assert_arg
****0 local types = {}

      --- is the object either a function or a callable object?.
      -- @param obj Object to check.
****0 function types.is_callable (obj)
****0     return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call and true
      end

      --- is the object of the specified type?.
      -- If the type is a string, then use type, otherwise compare with metatable.
      --
      -- NOTE: this function is imported from `utils.is_type`.
      -- @param obj An object to check
      -- @param tp The expected type
      -- @function is_type
      -- @see utils.is_type
****0 types.is_type = utils.is_type

****0 local fileMT = getmetatable(io.stdout)

      --- a string representation of a type.
      -- For tables and userdata with metatables, we assume that the metatable has a `_name`
      -- field. If the field is not present it will return 'unknown table' or
      -- 'unknown userdata'.
      -- Lua file objects return the type 'file'.
      -- @param obj an object
      -- @return a string like 'number', 'table', 'file' or 'List'
****0 function types.type (obj)
****0     local t = type(obj)
****0     if t == 'table' or t == 'userdata' then
****0         local mt = getmetatable(obj)
****0         if mt == fileMT then
****0             return 'file'
****0         elseif mt == nil then
****0             return t
              else
                  -- TODO: the "unknown" is weird, it should just return the type
****0             return mt._name or "unknown "..t
              end
          else
****0         return t
          end
      end

      --- is this number an integer?
      -- @param x a number
      -- @raise error if x is not a number
      -- @return boolean
****0 function types.is_integer (x)
****0     return math_ceil(x)==x
      end

      --- Check if the object is "empty".
      -- An object is considered empty if it is:
      --
      -- - `nil`
      -- - a table without any items (key-value pairs or indexes)
      -- - a string with no content ("")
      -- - not a nil/table/string
      -- @param o The object to check if it is empty.
      -- @param ignore_spaces If the object is a string and this is true the string is
      -- considered empty if it only contains spaces.
      -- @return `true` if the object is empty, otherwise a falsy value.
****0 function types.is_empty(o, ignore_spaces)
****0     if o == nil then
****0         return true
****0     elseif type(o) == "table" then
****0         return next(o) == nil
****0     elseif type(o) == "string" then
****0         return o == "" or (not not ignore_spaces and (not not o:find("^%s+$")))
          else
****0         return true
          end
      end

      local function check_meta (val)
    2     if type(val) == 'table' then return true end
****0     return getmetatable(val)
      end

      --- is an object 'array-like'?
      -- An object is array like if:
      --
      -- - it is a table, or
      -- - it has a metatable with `__len` and `__index` methods
      --
      -- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata
      -- @param val any value.
      -- @return `true` if the object is array-like, otherwise a falsy value.
****0 function types.is_indexable (val)
****0     local mt = check_meta(val)
****0     if mt == true then return true end
****0     return mt and mt.__len and mt.__index and true
      end

      --- can an object be iterated over with `pairs`?
      -- An object is iterable if:
      --
      -- - it is a table, or
      -- - it has a metatable with a `__pairs` meta method
      --
      -- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata
      -- @param val any value.
      -- @return `true` if the object is iterable, otherwise a falsy value.
****0 function types.is_iterable (val)
    2     local mt = check_meta(val)
    2     if mt == true then return true end
****0     return mt and mt.__pairs and true
      end

      --- can an object accept new key/pair values?
      -- An object is iterable if:
      --
      -- - it is a table, or
      -- - it has a metatable with a `__newindex` meta method
      --
      -- @param val any value.
      -- @return `true` if the object is writeable, otherwise a falsy value.
****0 function types.is_writeable (val)
****0     local mt = check_meta(val)
****0     if mt == true then return true end
****0     return mt and mt.__newindex and true
      end

      -- Strings that should evaluate to true.   -- TODO: add on/off ???
****0 local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
      -- Conditions types should evaluate to true.
****0 local true_types = {
          boolean=function(o, true_strs, check_objs) return o end,
          string=function(o, true_strs, check_objs)
****0         o = o:lower()
****0         if trues[o] then
****0             return true
              end
              -- Check alternative user provided strings.
****0         for _,v in ipairs(true_strs or {}) do
****0             if type(v) == "string" and o == v:lower() then
****0                 return true
                  end
              end
****0         return false
          end,
          number=function(o, true_strs, check_objs) return o ~= 0 end,
****0     table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
      }
      --- Convert to a boolean value.
      -- True values are:
      --
      -- * boolean: true.
      -- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
      -- * number: Any non-zero value.
      -- * table: Is not empty and `check_objs` is true.
      -- * everything else: Is not `nil` and `check_objs` is true.
      --
      -- @param o The object to evaluate.
      -- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
      -- This should be a List of strings. E.g. "ja" to support German.
      -- @param[opt] check_objs True if objects should be evaluated.
      -- @return true if the input evaluates to true, otherwise false.
****0 function types.to_bool(o, true_strs, check_objs)
          local true_func
****0     if true_strs then
****0         assert_arg(2, true_strs, "table")
          end
****0     true_func = true_types[type(o)]
****0     if true_func then
****0         return true_func(o, true_strs, check_objs)
****0     elseif check_objs and o ~= nil then
****0         return true
          end
****0     return false
      end


****0 return types

==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/pl/utils.lua
==============================================================================
      --- Generally useful routines.
      -- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
      --
      -- Dependencies: `pl.compat`, all exported fields and functions from
      -- `pl.compat` are also available in this module.
      --
      -- @module pl.utils
****0 local format = string.format
****0 local compat = require 'pl.compat'
****0 local stdout = io.stdout
****0 local append = table.insert
****0 local concat = table.concat
****0 local _unpack = table.unpack  -- always injected by 'compat'
****0 local find = string.find
****0 local sub = string.sub
****0 local next = next
****0 local floor = math.floor

****0 local is_windows = compat.is_windows
****0 local err_mode = 'default'
      local raise
      local operators
****0 local _function_factories = {}


****0 local utils = { _VERSION = "1.14.0" }
****0 for k, v in pairs(compat) do utils[k] = v  end

      --- Some standard patterns
      -- @table patterns
****0 utils.patterns = {
          FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number
          INTEGER = '[+%-%d]%d*',                     -- integer number
          IDEN = '[%a_][%w_]*',                       -- identifier
          FILE = '[%a%.\\][:%][%w%._%-\\]*',          -- file
      }


      --- Standard meta-tables as used by other Penlight modules
      -- @table stdmt
      -- @field List the List metatable
      -- @field Map the Map metatable
      -- @field Set the Set metatable
      -- @field MultiMap the MultiMap metatable
****0 utils.stdmt = {
          List = {_name='List'},
          Map = {_name='Map'},
          Set = {_name='Set'},
          MultiMap = {_name='MultiMap'},
      }


      --- pack an argument list into a table.
      -- @param ... any arguments
      -- @return a table with field `n` set to the length
      -- @function utils.pack
      -- @see compat.pack
      -- @see utils.npairs
      -- @see utils.unpack
****0 utils.pack = table.pack  -- added here to be symmetrical with unpack

      --- unpack a table and return its contents.
      --
      -- NOTE: this implementation differs from the Lua implementation in the way
      -- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.
      -- @param t table to unpack
      -- @param[opt] i index from which to start unpacking, defaults to 1
      -- @param[opt] j index of the last element to unpack, defaults to `t.n` or else `#t`
      -- @return multiple return values from the table
      -- @function utils.unpack
      -- @see compat.unpack
      -- @see utils.pack
      -- @see utils.npairs
      -- @usage
      -- local t = table.pack(nil, nil, nil, 4)
      -- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil
      --
      -- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4
****0 function utils.unpack(t, i, j)
****0     return _unpack(t, i or 1, j or t.n or #t)
      end

      --- print an arbitrary number of arguments using a format.
      -- Output will be sent to `stdout`.
      -- @param fmt The format (see `string.format`)
      -- @param ... Extra arguments for format
****0 function utils.printf(fmt, ...)
****0     utils.assert_string(1, fmt)
****0     utils.fprintf(stdout, fmt, ...)
      end

      --- write an arbitrary number of arguments to a file using a format.
      -- @param f File handle to write to.
      -- @param fmt The format (see `string.format`).
      -- @param ... Extra arguments for format
****0 function utils.fprintf(f,fmt,...)
****0     utils.assert_string(2,fmt)
****0     f:write(format(fmt,...))
      end

      do
          local function import_symbol(T,k,v,libname)
****0         local key = rawget(T,k)
              -- warn about collisions!
****0         if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
****0             utils.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",libname,k)
****0             return
              end
****0         rawset(T,k,v)
          end

          local function lookup_lib(T,t)
****0         for k,v in pairs(T) do
****0             if v == t then return k end
              end
****0         return '?'
          end

****0     local already_imported = {}

          --- take a table and 'inject' it into the local namespace.
          -- @param t The table (table), or module name (string), defaults to this `utils` module table
          -- @param T An optional destination table (defaults to callers environment)
****0     function utils.import(t,T)
****0         T = T or _G
****0         t = t or utils
****0         if type(t) == 'string' then
****0             t = require (t)
              end
****0         local libname = lookup_lib(T,t)
****0         if already_imported[t] then return end
****0         already_imported[t] = libname
****0         for k,v in pairs(t) do
****0             import_symbol(T,k,v,libname)
              end
          end
      end

      --- return either of two values, depending on a condition.
      -- @param cond A condition
      -- @param value1 Value returned if cond is truthy
      -- @param value2 Value returned if cond is falsy
****0 function utils.choose(cond, value1, value2)
****0     if cond then
****0         return value1
          else
****0         return value2
          end
      end

      --- convert an array of values to strings.
      -- @param t a list-like table
      -- @param[opt] temp (table) buffer to use, otherwise allocate
      -- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.
      -- @return the converted buffer
****0 function utils.array_tostring (t,temp,tostr)
****0     temp, tostr = temp or {}, tostr or tostring
****0     for i = 1,#t do
****0         temp[i] = tostr(t[i],i)
          end
****0     return temp
      end



      --- is the object of the specified type?
      -- If the type is a string, then use type, otherwise compare with metatable
      -- @param obj An object to check
      -- @param tp String of what type it should be
      -- @return boolean
      -- @usage utils.is_type("hello world", "string")   --> true
      -- -- or check metatable
      -- local my_mt = {}
      -- local my_obj = setmetatable(my_obj, my_mt)
      -- utils.is_type(my_obj, my_mt)  --> true
****0 function utils.is_type (obj,tp)
****0     if type(tp) == 'string' then return type(obj) == tp end
****0     local mt = getmetatable(obj)
****0     return tp == mt
      end



      --- an iterator with indices, similar to `ipairs`, but with a range.
      -- This is a nil-safe index based iterator that will return `nil` when there
      -- is a hole in a list. To be safe ensure that table `t.n` contains the length.
      -- @tparam table t the table to iterate over
      -- @tparam[opt=1] integer i_start start index
      -- @tparam[opt=t.n or #t] integer i_end end index
      -- @tparam[opt=1] integer step step size
      -- @treturn integer index
      -- @treturn any value at index (which can be `nil`!)
      -- @see utils.pack
      -- @see utils.unpack
      -- @usage
      -- local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing
      --
      -- for i, v in utils.npairs(t, 2) do  -- start at index 2
      --   t[i] = tostring(t[i])
      -- end
      --
      -- -- t = { n = 3, [2] = "123", [3] = "nil" }
****0 function utils.npairs(t, i_start, i_end, step)
****0   step = step or 1
****0   if step == 0 then
****0     error("iterator step-size cannot be 0", 2)
        end
****0   local i = (i_start or 1) - step
****0   i_end = i_end or t.n or #t
****0   if step < 0 then
          return function()
****0       i = i + step
****0       if i < i_end then
****0         return nil
            end
****0       return i, t[i]
          end

        else
          return function()
****0       i = i + step
****0       if i > i_end then
****0         return nil
            end
****0       return i, t[i]
          end
        end
      end



      --- an iterator over all non-integer keys (inverse of `ipairs`).
      -- It will skip any key that is an integer number, so negative indices or an
      -- array with holes will not return those either (so it returns slightly less than
      -- 'the inverse of `ipairs`').
      --
      -- This uses `pairs` under the hood, so any value that is iterable using `pairs`
      -- will work with this function.
      -- @tparam table t the table to iterate over
      -- @treturn key
      -- @treturn value
      -- @usage
      -- local t = {
      --   "hello",
      --   "world",
      --   hello = "hallo",
      --   world = "Welt",
      -- }
      --
      -- for k, v in utils.kpairs(t) do
      --   print("German: ", v)
      -- end
      --
      -- -- output;
      -- -- German: hallo
      -- -- German: Welt
****0 function utils.kpairs(t)
        local index
        return function()
          local value
          while true do
****0       index, value = next(t, index)
****0       if type(index) ~= "number" or floor(index) ~= index then
              break
            end
          end
****0     return index, value
        end
      end



      --- Error handling
      -- @section Error-handling

      --- assert that the given argument is in fact of the correct type.
      -- @param n argument index
      -- @param val the value
      -- @param tp the type
      -- @param verify an optional verification function
      -- @param msg an optional custom message
      -- @param lev optional stack position for trace, default 2
      -- @return the validated value
      -- @raise if `val` is not the correct type
      -- @usage
      -- local param1 = assert_arg(1,"hello",'table')  --> error: argument 1 expected a 'table', got a 'string'
      -- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')
      --      --> error: argument 4: '!@#$%^&*' not a directory
****0 function utils.assert_arg (n,val,tp,verify,msg,lev)
  108     if type(val) ~= tp then
****0         error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
          end
  108     if verify and not verify(val) then
****0         error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
          end
  108     return val
      end

      --- creates an Enum or constants lookup table for improved error handling.
      -- This helps prevent magic strings in code by throwing errors for accessing
      -- non-existing values, and/or converting strings/identifiers to other values.
      --
      -- Calling on the object does the same, but returns a soft error; `nil + err`, if
      -- the call is successful (the key exists), it will return the value.
      --
      -- When calling with varargs or an array the values will be equal to the keys.
      -- The enum object is read-only.
      -- @tparam table|vararg ... the input for the Enum. If varargs or an array then the
      -- values in the Enum will be equal to the names (must be strings), if a hash-table
      -- then values remain (any type), and the keys must be strings.
      -- @return Enum object (read-only table/object)
      -- @usage -- Enum access at runtime
      -- local obj = {}
      -- obj.MOVEMENT = utils.enum("FORWARD", "REVERSE", "LEFT", "RIGHT")
      --
      -- if current_movement == obj.MOVEMENT.FORWARD then
      --   -- do something
      --
      -- elseif current_movement == obj.MOVEMENT.REVERES then
      --   -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error
      --   -- "'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')"
      --
      -- end
      -- @usage -- standardized error codes
      -- local obj = {
      --   ERR = utils.enum {
      --     NOT_FOUND = "the item was not found",
      --     OUT_OF_BOUNDS = "the index is outside the allowed range"
      --   },
      --
      --   some_method = function(self)
      --     return nil, self.ERR.OUT_OF_BOUNDS
      --   end,
      -- }
      --
      -- local result, err = obj:some_method()
      -- if not result then
      --   if err == obj.ERR.NOT_FOUND then
      --     -- check on error code, not magic strings
      --
      --   else
      --     -- return the error description, contained in the constant
      --     return nil, "error: "..err  -- "error: the index is outside the allowed range"
      --   end
      -- end
      -- @usage -- validating/converting user-input
      -- local color = "purple"
      -- local ansi_colors = utils.enum {
      --   black     = 30,
      --   red       = 31,
      --   green     = 32,
      -- }
      -- local color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum
      -- if not color_code then
      --   print("bad 'color', " .. err)
      --   -- "bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')"
      --   os.exit(1)
      -- end
****0 function utils.enum(...)
****0   local first = select(1, ...)
****0   local enum = {}
        local lst

****0   if type(first) ~= "table" then
          -- vararg with strings
****0     lst = utils.pack(...)
****0     for i, value in utils.npairs(lst) do
****0       utils.assert_arg(i, value, "string")
****0       enum[value] = value
          end

        else
          -- table/array with values
****0     utils.assert_arg(1, first, "table")
****0     lst = {}
          -- first add array part
****0     for i, value in ipairs(first) do
****0       if type(value) ~= "string" then
****0         error(("expected 'string' but got '%s' at index %d"):format(type(value), i), 2)
            end
****0       lst[i] = value
****0       enum[value] = value
          end
          -- add key-ed part
****0     for key, value in utils.kpairs(first) do
****0       if type(key) ~= "string" then
****0         error(("expected key to be 'string' but got '%s'"):format(type(key)), 2)
            end
****0       if enum[key] then
****0         error(("duplicate entry in array and hash part: '%s'"):format(key), 2)
            end
****0       enum[key] = value
****0       lst[#lst+1] = key
          end
        end

****0   if not lst[1] then
****0     error("expected at least 1 entry", 2)
        end

****0   local valid = "(expected one of: '" .. concat(lst, "', '") .. "')"
****0   setmetatable(enum, {
          __index = function(self, key)
****0       error(("'%s' is not a valid value %s"):format(tostring(key), valid), 2)
          end,
          __newindex = function(self, key, value)
****0       error("the Enum object is read-only", 2)
          end,
          __call = function(self, key)
****0       if type(key) == "string" then
****0         local v = rawget(self, key)
****0         if v ~= nil then
****0           return v
              end
            end
****0       return nil, ("'%s' is not a valid value %s"):format(tostring(key), valid)
          end
        })

****0   return enum
      end


      --- process a function argument.
      -- This is used throughout Penlight and defines what is meant by a function:
      -- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
      -- such as '>' or '#'. If a function factory has been registered for the type, it will
      -- be called to get the function.
      -- @param idx argument index
      -- @param f a function, operator string, or callable object
      -- @param msg optional error message
      -- @return a callable
      -- @raise if idx is not a number or if f is not callable
****0 function utils.function_arg (idx,f,msg)
****0     utils.assert_arg(1,idx,'number')
****0     local tp = type(f)
****0     if tp == 'function' then return f end  -- no worries!
          -- ok, a string can correspond to an operator (like '==')
****0     if tp == 'string' then
****0         if not operators then operators = require 'pl.operator'.optable end
****0         local fn = operators[f]
****0         if fn then return fn end
****0         local fn, err = utils.string_lambda(f)
****0         if not fn then error(err..': '..f) end
****0         return fn
****0     elseif tp == 'table' or tp == 'userdata' then
****0         local mt = getmetatable(f)
****0         if not mt then error('not a callable object',2) end
****0         local ff = _function_factories[mt]
****0         if not ff then
****0             if not mt.__call then error('not a callable object',2) end
****0             return f
              else
****0             return ff(f) -- we have a function factory for this type!
              end
          end
****0     if not msg then msg = " must be callable" end
****0     if idx > 0 then
****0         error("argument "..idx..": "..msg,2)
          else
****0         error(msg,2)
          end
      end


      --- assert the common case that the argument is a string.
      -- @param n argument index
      -- @param val a value that must be a string
      -- @return the validated value
      -- @raise val must be a string
      -- @usage
      -- local val = 42
      -- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'
****0 function utils.assert_string (n, val)
  107     return utils.assert_arg(n,val,'string',nil,nil,3)
      end

      --- control the error strategy used by Penlight.
      -- This is a global setting that controls how `utils.raise` behaves:
      --
      -- - 'default': return `nil + error` (this is the default)
      -- - 'error': throw a Lua error
      -- - 'quit': exit the program
      --
      -- @param mode either 'default', 'quit'  or 'error'
      -- @see utils.raise
****0 function utils.on_error (mode)
****0     mode = tostring(mode)
****0     if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
****0       err_mode = mode
          else
            -- fail loudly
****0       local err = "Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'"
****0       if err_mode == 'default' then
****0         error(err, 2)  -- even in 'default' mode fail loud in this case
            end
****0       raise(err)
          end
      end

      --- used by Penlight functions to return errors. Its global behaviour is controlled
      -- by `utils.on_error`.
      -- To use this function you MUST use it in conjunction with `return`, since it might
      -- return `nil + error`.
      -- @param err the error string.
      -- @see utils.on_error
      -- @usage
      -- if some_condition then
      --   return utils.raise("some condition was not met")  -- MUST use 'return'!
      -- end
****0 function utils.raise (err)
****0     if err_mode == 'default' then
****0         return nil, err
****0     elseif err_mode == 'quit' then
****0         return utils.quit(err)
          else
****0         error(err, 2)
          end
      end
****0 raise = utils.raise



      --- File handling
      -- @section files

      --- return the contents of a file as a string
      -- @param filename The file path
      -- @param is_bin open in binary mode
      -- @return file contents
****0 function utils.readfile(filename,is_bin)
****0     local mode = is_bin and 'b' or ''
****0     utils.assert_string(1,filename)
****0     local f,open_err = io.open(filename,'r'..mode)
****0     if not f then return raise (open_err) end
****0     local res,read_err = f:read('*a')
****0     f:close()
****0     if not res then
              -- Errors in io.open have "filename: " prefix,
              -- error in file:read don't, add it.
****0         return raise (filename..": "..read_err)
          end
****0     return res
      end

      --- write a string to a file
      -- @param filename The file path
      -- @param str The string
      -- @param is_bin open in binary mode
      -- @return true or nil
      -- @return error message
      -- @raise error if filename or str aren't strings
****0 function utils.writefile(filename,str,is_bin)
****0     local mode = is_bin and 'b' or ''
****0     utils.assert_string(1,filename)
****0     utils.assert_string(2,str)
****0     local f,err = io.open(filename,'w'..mode)
****0     if not f then return raise(err) end
****0     local ok, write_err = f:write(str)
****0     f:close()
****0     if not ok then
              -- Errors in io.open have "filename: " prefix,
              -- error in file:write don't, add it.
****0         return raise (filename..": "..write_err)
          end
****0     return true
      end

      --- return the contents of a file as a list of lines
      -- @param filename The file path
      -- @return file contents as a table
      -- @raise error if filename is not a string
****0 function utils.readlines(filename)
****0     utils.assert_string(1,filename)
****0     local f,err = io.open(filename,'r')
****0     if not f then return raise(err) end
****0     local res = {}
****0     for line in f:lines() do
****0         append(res,line)
          end
****0     f:close()
****0     return res
      end

      --- OS functions
      -- @section OS-functions

      --- execute a shell command and return the output.
      -- This function redirects the output to tempfiles and returns the content of those files.
      -- @param cmd a shell command
      -- @param bin boolean, if true, read output as binary file
      -- @return true if successful
      -- @return actual return code
      -- @return stdout output (string)
      -- @return errout output (string)
****0 function utils.executeex(cmd, bin)
****0     local outfile = os.tmpname()
****0     local errfile = os.tmpname()

****0     if is_windows and not outfile:find(':') then
****0         outfile = os.getenv('TEMP')..outfile
****0         errfile = os.getenv('TEMP')..errfile
          end
****0     cmd = cmd .. " > " .. utils.quote_arg(outfile) .. " 2> " .. utils.quote_arg(errfile)

****0     local success, retcode = utils.execute(cmd)
****0     local outcontent = utils.readfile(outfile, bin)
****0     local errcontent = utils.readfile(errfile, bin)
****0     os.remove(outfile)
****0     os.remove(errfile)
****0     return success, retcode, (outcontent or ""), (errcontent or "")
      end

      --- Quote and escape an argument of a command.
      -- Quotes a single (or list of) argument(s) of a command to be passed
      -- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.
      -- @param argument (string or table/list) the argument to quote. If a list then
      -- all arguments in the list will be returned as a single string quoted.
      -- @return quoted and escaped argument.
      -- @usage
      -- local options = utils.quote_arg {
      --     "-lluacov",
      --     "-e",
      --     "utils = print(require('pl.utils')._VERSION",
      -- }
      -- -- returns: -lluacov -e 'utils = print(require('\''pl.utils'\'')._VERSION'
****0 function utils.quote_arg(argument)
****0     if type(argument) == "table" then
              -- encode an entire table
****0         local r = {}
****0         for i, arg in ipairs(argument) do
****0             r[i] = utils.quote_arg(arg)
              end

****0         return concat(r, " ")
          end
          -- only a single argument
****0     if is_windows then
****0         if argument == "" or argument:find('[ \f\t\v]') then
                  -- Need to quote the argument.
                  -- Quotes need to be escaped with backslashes;
                  -- additionally, backslashes before a quote, escaped or not,
                  -- need to be doubled.
                  -- See documentation for CommandLineToArgvW Windows function.
****0             argument = '"' .. argument:gsub([[(\*)"]], [[%1%1\"]]):gsub([[\+$]], "%0%0") .. '"'
              end

              -- os.execute() uses system() C function, which on Windows passes command
              -- to cmd.exe. Escape its special characters.
****0         return (argument:gsub('["^<>!|&%%]', "^%0"))
          else
****0         if argument == "" or argument:find('[^a-zA-Z0-9_@%+=:,./-]') then
                  -- To quote arguments on posix-like systems use single quotes.
                  -- To represent an embedded single quote close quoted string ('),
                  -- add escaped quote (\'), open quoted string again (').
****0             argument = "'" .. argument:gsub("'", [['\'']]) .. "'"
              end

****0         return argument
          end
      end

      --- error out of this program gracefully.
      -- @param[opt] code The exit code, defaults to -`1` if omitted
      -- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)
      -- @param ... extra arguments for message's format'
      -- @see utils.fprintf
      -- @usage utils.quit(-1, "Error '%s' happened", "42")
      -- -- is equivalent to
      -- utils.quit("Error '%s' happened", "42")  --> Error '42' happened
****0 function utils.quit(code, msg, ...)
****0     if type(code) == 'string' then
****0         utils.fprintf(io.stderr, code, msg, ...)
****0         io.stderr:write('\n')
****0         code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code
****0     elseif msg then
****0         utils.fprintf(io.stderr, msg, ...)
****0         io.stderr:write('\n')
          end
****0     os.exit(code, true)
      end


      --- String functions
      -- @section string-functions

      --- escape any Lua 'magic' characters in a string
      -- @param s The input string
****0 function utils.escape(s)
****0     utils.assert_string(1,s)
****0     return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
      end

      --- split a string into a list of strings separated by a delimiter.
      -- @param s The input string
      -- @param re optional A Lua string pattern; defaults to '%s+'
      -- @param plain optional If truthy don't use Lua patterns
      -- @param n optional maximum number of elements (if there are more, the last will remain un-split)
      -- @return a list-like table
      -- @raise error if s is not a string
      -- @see splitv
****0 function utils.split(s,re,plain,n)
****0     utils.assert_string(1,s)
****0     local i1,ls = 1,{}
****0     if not re then re = '%s+' end
****0     if re == '' then return {s} end
          while true do
****0         local i2,i3 = find(s,re,i1,plain)
****0         if not i2 then
****0             local last = sub(s,i1)
****0             if last ~= '' then append(ls,last) end
****0             if #ls == 1 and ls[1] == '' then
****0                 return {}
                  else
****0                 return ls
                  end
              end
****0         append(ls,sub(s,i1,i2-1))
****0         if n and #ls == n then
****0             ls[#ls] = sub(s,i1)
****0             return ls
              end
****0         i1 = i3+1
          end
      end

      --- split a string into a number of return values.
      -- Identical to `split` but returns multiple sub-strings instead of
      -- a single list of sub-strings.
      -- @param s the string
      -- @param re A Lua string pattern; defaults to '%s+'
      -- @param plain don't use Lua patterns
      -- @param n optional maximum number of splits
      -- @return n values
      -- @usage first,next = splitv('user=jane=doe','=', false, 2)
      -- assert(first == "user")
      -- assert(next == "jane=doe")
      -- @see split
****0 function utils.splitv (s,re, plain, n)
****0     return _unpack(utils.split(s,re, plain, n))
      end


      --- Functional
      -- @section functional


      --- 'memoize' a function (cache returned value for next call).
      -- This is useful if you have a function which is relatively expensive,
      -- but you don't know in advance what values will be required, so
      -- building a table upfront is wasteful/impossible.
      -- @param func a function that takes exactly one argument (which later serves as the cache key) and returns a single value
      -- @return a function taking one argument and returning a single value either from the cache or by running the original input function
****0 function utils.memoize(func)
****0     local cache = {}
          return function(k)
****0         local res = cache[k]
****0         if res == nil then
****0             res = func(k)
****0             cache[k] = res
              end
****0         return res
          end
      end


      --- associate a function factory with a type.
      -- A function factory takes an object of the given type and
      -- returns a function for evaluating it
      -- @tab mt metatable
      -- @func fun a callable that returns a function
****0 function utils.add_function_factory (mt,fun)
****0     _function_factories[mt] = fun
      end

      local function _string_lambda(f)
****0     if f:find '^|' or f:find '_' then
****0         local args,body = f:match '|([^|]*)|(.+)'
****0         if f:find '_' then
****0             args = '_'
****0             body = f
              else
****0             if not args then return raise 'bad string lambda' end
              end
****0         local fstr = 'return function('..args..') return '..body..' end'
****0         local fn,err = utils.load(fstr)
****0         if not fn then return raise(err) end
****0         fn = fn()
****0         return fn
          else
****0         return raise 'not a string lambda'
          end
      end


      --- an anonymous function as a string. This string is either of the form
      -- '|args| expression' or is a function of one argument, '_'
      -- @param lf function as a string
      -- @return a function
      -- @function utils.string_lambda
      -- @usage
      -- string_lambda '|x|x+1' (2) == 3
      -- string_lambda '_+1' (2) == 3
****0 utils.string_lambda = utils.memoize(_string_lambda)


      --- bind the first argument of the function to a value.
      -- @param fn a function of at least two values (may be an operator string)
      -- @param p a value
      -- @return a function such that f(x) is fn(p,x)
      -- @raise same as @{function_arg}
      -- @see func.bind1
      -- @usage local function f(msg, name)
      --   print(msg .. " " .. name)
      -- end
      --
      -- local hello = utils.bind1(f, "Hello")
      --
      -- print(hello("world"))     --> "Hello world"
      -- print(hello("sunshine"))  --> "Hello sunshine"
****0 function utils.bind1 (fn,p)
****0     fn = utils.function_arg(1,fn)
****0     return function(...) return fn(p,...) end
      end


      --- bind the second argument of the function to a value.
      -- @param fn a function of at least two values (may be an operator string)
      -- @param p a value
      -- @return a function such that f(x) is fn(x,p)
      -- @raise same as @{function_arg}
      -- @usage local function f(a, b, c)
      --   print(a .. " " .. b .. " " .. c)
      -- end
      --
      -- local hello = utils.bind1(f, "world")
      --
      -- print(hello("Hello", "!"))  --> "Hello world !"
      -- print(hello("Bye", "?"))    --> "Bye world ?"
****0 function utils.bind2 (fn,p)
****0     fn = utils.function_arg(1,fn)
****0     return function(x,...) return fn(x,p,...) end
      end




      --- Deprecation
      -- @section deprecation

      do
        -- the default implementation
        local deprecation_func = function(msg, trace)
****0     if trace then
****0       warn(msg, "\n", trace)  -- luacheck: ignore
          else
****0       warn(msg)  -- luacheck: ignore
          end
        end

        --- Sets a deprecation warning function.
        -- An application can override this function to support proper output of
        -- deprecation warnings. The warnings can be generated from libraries or
        -- functions by calling `utils.raise_deprecation`. The default function
        -- will write to the 'warn' system (introduced in Lua 5.4, or the compatibility
        -- function from the `compat` module for earlier versions).
        --
        -- Note: only applications should set/change this function, libraries should not.
        -- @param func a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional.
        -- @see utils.raise_deprecation
        -- @usage
        -- -- write to the Nginx logs with OpenResty
        -- utils.set_deprecation_func(function(msg, trace)
        --   ngx.log(ngx.WARN, msg, (trace and (" " .. trace) or nil))
        -- end)
        --
        -- -- disable deprecation warnings
        -- utils.set_deprecation_func()
****0   function utils.set_deprecation_func(func)
****0     if func == nil then
****0       deprecation_func = function() end
          else
****0       utils.assert_arg(1, func, "function")
****0       deprecation_func = func
          end
        end

        --- raises a deprecation warning.
        -- For options see the usage example below.
        --
        -- Note: the `opts.deprecated_after` field is the last version in which
        -- a feature or option was NOT YET deprecated! Because when writing the code it
        -- is quite often not known in what version the code will land. But the last
        -- released version is usually known.
        -- @param opts options table
        -- @see utils.set_deprecation_func
        -- @usage
        -- warn("@on")   -- enable Lua warnings, they are usually off by default
        --
        -- function stringx.islower(str)
        --   raise_deprecation {
        --     source = "Penlight " .. utils._VERSION,                   -- optional
        --     message = "function 'islower' was renamed to 'is_lower'", -- required
        --     version_removed = "2.0.0",                                -- optional
        --     deprecated_after = "1.2.3",                               -- optional
        --     no_trace = true,                                          -- optional
        --   }
        --   return stringx.is_lower(str)
        -- end
        -- -- output: "[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)"
****0   function utils.raise_deprecation(opts)
****0     utils.assert_arg(1, opts, "table")
****0     if type(opts.message) ~= "string" then
****0       error("field 'message' of the options table must be a string", 2)
          end
          local trace
****0     if not opts.no_trace then
****0       trace = debug.traceback("", 2):match("[\n%s]*(.-)$")
          end
          local msg
****0     if opts.deprecated_after and opts.version_removed then
****0       msg = (" (deprecated after %s, scheduled for removal in %s)"):format(
****0         tostring(opts.deprecated_after), tostring(opts.version_removed))
****0     elseif opts.deprecated_after then
****0       msg = (" (deprecated after %s)"):format(tostring(opts.deprecated_after))
****0     elseif opts.version_removed then
****0       msg = (" (scheduled for removal in %s)"):format(tostring(opts.version_removed))
          else
****0       msg = ""
          end

****0     msg = opts.message .. msg

****0     if opts.source then
****0       msg = "[" .. opts.source .."] " .. msg
          else
****0       if msg:sub(1,1) == "@" then
              -- in Lua 5.4 "@" prefixed messages are control messages to the warn system
****0         error("message cannot start with '@'", 2)
            end
          end

****0     deprecation_func(msg, trace)
        end

      end


****0 return utils



==============================================================================
/home/ubuntu/.luarocks/share/lua/5.1/say/init.lua
==============================================================================
****0 local unpack = table.unpack or unpack

****0 local registry = { }
      local current_namespace
      local fallback_namespace

****0 local s = {

        _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
        _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
        _VERSION     = "Say 1.3",

        set_namespace = function(self, namespace)
    1     current_namespace = namespace
    1     if not registry[current_namespace] then
****0       registry[current_namespace] = {}
          end
        end,

        set_fallback = function(self, namespace)
****0     fallback_namespace = namespace
****0     if not registry[fallback_namespace] then
****0       registry[fallback_namespace] = {}
          end
        end,

        set = function(self, key, value)
   19     registry[current_namespace][key] = value
        end
      }

****0 local __meta = {
        __call = function(self, key, vars)
   30     if vars ~= nil and type(vars) ~= "table" then
****0       error(("expected parameter table to be a table, got '%s'"):format(type(vars)), 2)
          end
   30     vars = vars or {}
   30     vars.n = math.max((vars.n or 0), #vars)

   30     local str = registry[current_namespace][key] or registry[fallback_namespace][key]

   30     if str == nil then
****0       return nil
          end
   30     str = tostring(str)
   30     local strings = {}

   93     for i = 1, vars.n or #vars do
   63       table.insert(strings, tostring(vars[i]))
          end

   30     return #strings > 0 and str:format(unpack(strings)) or str
        end,

        __index = function(self, key)
****0     return registry[key]
        end
      }

****0 s:set_fallback('en')
****0 s:set_namespace('en')

****0 s._registry = registry

****0 return setmetatable(s, __meta)

==============================================================================
/usr/share/lua/5.1/luarocks/core/dir.lua
==============================================================================

****0 local dir = {}

      local require = nil
      --------------------------------------------------------------------------------

      local function unquote(c)
  184    local first, last = c:sub(1,1), c:sub(-1)
  184    if (first == '"' and last == '"') or
  184       (first == "'" and last == "'") then
****0       return c:sub(2,-2)
         end
  184    return c
      end

      --- Describe a path in a cross-platform way.
      -- Use this function to avoid platform-specific directory
      -- separators in other modules. Removes trailing slashes from
      -- each component given, to avoid repeated separators.
      -- Separators inside strings are kept, to handle URLs containing
      -- protocols.
      -- @param ... strings representing directories
      -- @return string: a string with a platform-specific representation
      -- of the path.
****0 function dir.path(...)
   46    local t = {...}
   46    while t[1] == "" do
****0       table.remove(t, 1)
         end
  138    for i, c in ipairs(t) do
   92       t[i] = unquote(c)
         end
   46    return (table.concat(t, "/"):gsub("([^:])/+", "%1/"):gsub("^/+", "/"):gsub("/*$", ""))
      end

      --- Split protocol and path from an URL or local pathname.
      -- URLs should be in the "protocol://path" format.
      -- For local pathnames, "file" is returned as the protocol.
      -- @param url string: an URL or a local pathname.
      -- @return string, string: the protocol, and the pathname without the protocol.
****0 function dir.split_url(url)
   92    assert(type(url) == "string")

   92    url = unquote(url)
   92    local protocol, pathname = url:match("^([^:]*)://(.*)")
   92    if not protocol then
   92       protocol = "file"
   92       pathname = url
         end
   92    return protocol, pathname
      end

      --- Normalize a url or local path.
      -- URLs should be in the "protocol://path" format. System independent
      -- forward slashes are used, removing trailing and double slashes
      -- @param url string: an URL or a local pathname.
      -- @return string: Normalized result.
****0 function dir.normalize(name)
   92    local protocol, pathname = dir.split_url(name)
   92    pathname = pathname:gsub("\\", "/"):gsub("(.)/*$", "%1"):gsub("//", "/")
   92    local pieces = {}
   92    local drive = ""
   92    if pathname:match("^.:") then
****0       drive, pathname = pathname:match("^(.:)(.*)$")
         end
  345    for piece in pathname:gmatch("(.-)/") do
  253       if piece == ".." then
****0          local prev = pieces[#pieces]
****0          if not prev or prev == ".." then
****0             table.insert(pieces, "..")
****0          elseif prev ~= "" then
****0             table.remove(pieces)
               end
  253       elseif piece ~= "." then
  253          table.insert(pieces, piece)
            end
         end
   92    local basename = pathname:match("[^/]+$")
   92    if basename then
   92       table.insert(pieces, basename)
         end
   92    pathname = drive .. table.concat(pieces, "/")
   92    if protocol ~= "file" then pathname = protocol .."://"..pathname end
   92    return pathname
      end

****0 return dir


==============================================================================
/usr/share/lua/5.1/luarocks/core/manif.lua
==============================================================================

      --- Core functions for querying manifest files.
****0 local manif = {}

****0 local persist = require("luarocks.core.persist")
****0 local cfg = require("luarocks.core.cfg")
****0 local dir = require("luarocks.core.dir")
****0 local util = require("luarocks.core.util")
****0 local vers = require("luarocks.core.vers")
****0 local path = require("luarocks.core.path")
      local require = nil
      --------------------------------------------------------------------------------

      -- Table with repository identifiers as keys and tables mapping
      -- Lua versions to cached loaded manifests as values.
****0 local manifest_cache = {}

      --- Cache a loaded manifest.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @param manifest table: the manifest to be cached.
****0 function manif.cache_manifest(repo_url, lua_version, manifest)
****0    lua_version = lua_version or cfg.lua_version
****0    manifest_cache[repo_url] = manifest_cache[repo_url] or {}
****0    manifest_cache[repo_url][lua_version] = manifest
      end

      --- Attempt to get cached loaded manifest.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @return table or nil: loaded manifest or nil if cache is empty.
****0 function manif.get_cached_manifest(repo_url, lua_version)
   46    lua_version = lua_version or cfg.lua_version
   46    return manifest_cache[repo_url] and manifest_cache[repo_url][lua_version]
      end

      --- Back-end function that actually loads the manifest
      -- and stores it in the manifest cache.
      -- @param file string: The local filename of the manifest file.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @return table or (nil, string, string): the manifest or nil,
      -- error message and error code ("open", "load", "run").
****0 function manif.manifest_loader(file, repo_url, lua_version)
****0    local manifest, err, errcode = persist.load_into_table(file)
****0    if not manifest then
****0       return nil, "Failed loading manifest for "..repo_url..": "..err, errcode
         end
****0    manif.cache_manifest(repo_url, lua_version, manifest)
****0    return manifest, err, errcode
      end

      --- Load a local manifest describing a repository.
      -- This is used by the luarocks.loader only.
      -- @param repo_url string: URL or pathname for the repository.
      -- @return table or (nil, string, string): A table representing the manifest,
      -- or nil followed by an error message and an error code, see manifest_loader.
****0 function manif.fast_load_local_manifest(repo_url)
   46    assert(type(repo_url) == "string")

   46    local cached_manifest = manif.get_cached_manifest(repo_url)
   46    if cached_manifest then
   46       return cached_manifest
         end

****0    local pathname = dir.path(repo_url, "manifest")
****0    return manif.manifest_loader(pathname, repo_url, nil, true)
      end

****0 function manif.load_rocks_tree_manifests(deps_mode)
   23    local trees = {}
   46    path.map_trees(deps_mode, function(tree)
   46       local manifest, err = manif.fast_load_local_manifest(path.rocks_dir(tree))
   46       if manifest then
   46          table.insert(trees, {tree=tree, manifest=manifest})
            end
         end)
   23    return trees
      end

****0 function manif.scan_dependencies(name, version, tree_manifests, dest)
   10    if dest[name] then
    9       return
         end
    1    dest[name] = version

    1    for _, tree in ipairs(tree_manifests) do
    1       local manifest = tree.manifest

            local pkgdeps
    1       if manifest.dependencies and manifest.dependencies[name] then
    1          pkgdeps = manifest.dependencies[name][version]
            end
    1       if pkgdeps then
    2          for _, dep in ipairs(pkgdeps) do
    1             local pkg, constraints = dep.name, dep.constraints

    3             for _, t in ipairs(tree_manifests) do
    2                local entries = t.manifest.repository[pkg]
    2                if entries then
****0                   for ver, _ in util.sortedpairs(entries, vers.compare_versions) do
****0                      if (not constraints) or vers.match_constraints(vers.parse_version(ver), constraints) then
****0                         manif.scan_dependencies(pkg, ver, tree_manifests, dest)
                           end
                        end
                     end
                  end
               end
    1          return
            end
         end
      end

****0 return manif

==============================================================================
/usr/share/lua/5.1/luarocks/core/path.lua
==============================================================================

      --- Core LuaRocks-specific path handling functions.
****0 local path = {}

****0 local cfg = require("luarocks.core.cfg")
****0 local dir = require("luarocks.core.dir")
      local require = nil
      --------------------------------------------------------------------------------

****0 function path.rocks_dir(tree)
   46    if tree == nil then
****0       tree = cfg.root_dir
         end
   46    if type(tree) == "string" then
   46       return dir.path(tree, cfg.rocks_subdir)
         end
****0    assert(type(tree) == "table")
****0    return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)
      end

      --- Produce a versioned version of a filename.
      -- @param file string: filename (must start with prefix)
      -- @param prefix string: Path prefix for file
      -- @param name string: Rock name
      -- @param version string: Rock version
      -- @return string: a pathname with the same directory parts and a versioned basename.
****0 function path.versioned_name(file, prefix, name, version)
****0    assert(type(file) == "string")
****0    assert(type(name) == "string" and not name:match("/"))
****0    assert(type(version) == "string")

****0    local rest = file:sub(#prefix+1):gsub("^/*", "")
****0    local name_version = (name.."_"..version):gsub("%-", "_"):gsub("%.", "_")
****0    return dir.path(prefix, name_version.."-"..rest)
      end

      --- Convert a pathname to a module identifier.
      -- In Unix, for example, a path "foo/bar/baz.lua" is converted to
      -- "foo.bar.baz"; "bla/init.lua" returns "bla.init"; "foo.so" returns "foo".
      -- @param file string: Pathname of module
      -- @return string: The module identifier, or nil if given path is
      -- not a conformant module path (the function does not check if the
      -- path actually exists).
****0 function path.path_to_module(file)
   11    assert(type(file) == "string")

   11    local name = file:match("(.*)%."..cfg.lua_extension.."$")
   11    if name then
   11       name = name:gsub("/", ".")
         else
****0       name = file:match("(.*)%."..cfg.lib_extension.."$")
****0       if name then
****0          name = name:gsub("/", ".")
            --[[ TODO disable static libs until we fix the conflict in the manifest, which will take extending the manifest format.
            else
               name = file:match("(.*)%."..cfg.static_lib_extension.."$")
               if name then
                  name = name:gsub("/", ".")
               end
            ]]
            end
         end
   11    if not name then name = file end
   11    name = name:gsub("^%.+", ""):gsub("%.+$", "")
   11    return name
      end

****0 function path.deploy_lua_dir(tree)
****0    if type(tree) == "string" then
****0       return dir.path(tree, cfg.lua_modules_path)
         else
****0       assert(type(tree) == "table")
****0       return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)
         end
      end

****0 function path.deploy_lib_dir(tree)
****0    if type(tree) == "string" then
****0       return dir.path(tree, cfg.lib_modules_path)
         else
****0       assert(type(tree) == "table")
****0       return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)
         end
      end

****0 local is_src_extension = { [".lua"] = true, [".tl"] = true, [".tld"] = true, [".moon"] = true }

      --- Return the pathname of the file that would be loaded for a module, indexed.
      -- @param file_name string: module file name as in manifest (eg. "socket/core.so")
      -- @param name string: name of the package (eg. "luasocket")
      -- @param version string: version number (eg. "2.0.2-1")
      -- @param tree string: repository path (eg. "/usr/local")
      -- @param i number: the index, 1 if version is the current default, > 1 otherwise.
      -- This is done this way for use by select_module in luarocks.loader.
      -- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
****0 function path.which_i(file_name, name, version, tree, i)
         local deploy_dir
****0    local extension = file_name:match("%.[a-z]+$")
****0    if is_src_extension[extension] then
****0       deploy_dir = path.deploy_lua_dir(tree)
****0       file_name = dir.path(deploy_dir, file_name)
         else
****0       deploy_dir = path.deploy_lib_dir(tree)
****0       file_name = dir.path(deploy_dir, file_name)
         end
****0    if i > 1 then
****0       file_name = path.versioned_name(file_name, deploy_dir, name, version)
         end
****0    return file_name
      end

****0 function path.rocks_tree_to_string(tree)
   92    if type(tree) == "string" then
   92       return tree
         else
****0       assert(type(tree) == "table")
****0       return tree.root
         end
      end

      --- Apply a given function to the active rocks trees based on chosen dependency mode.
      -- @param deps_mode string: Dependency mode: "one" for the current default tree,
      -- "all" for all trees, "order" for all trees with priority >= the current default,
      -- "none" for no trees (this function becomes a nop).
      -- @param fn function: function to be applied, with the tree dir (string) as the first
      -- argument and the remaining varargs of map_trees as the following arguments.
      -- @return a table with all results of invocations of fn collected.
****0 function path.map_trees(deps_mode, fn, ...)
   23    local result = {}
   23    local current = cfg.root_dir or cfg.rocks_trees[1]
   23    if deps_mode == "one" then
****0       table.insert(result, (fn(current, ...)) or 0)
         else
   23       local use = false
   23       if deps_mode == "all" then
****0          use = true
            end
   69       for _, tree in ipairs(cfg.rocks_trees or {}) do
   46          if dir.normalize(path.rocks_tree_to_string(tree)) == dir.normalize(path.rocks_tree_to_string(current)) then
   23             use = true
               end
   46          if use then
   46             table.insert(result, (fn(tree, ...)) or 0)
               end
            end
         end
   23    return result
      end

****0 return path

==============================================================================
/usr/share/lua/5.1/luarocks/core/vers.lua
==============================================================================

****0 local vers = {}

****0 local util = require("luarocks.core.util")
      local require = nil
      --------------------------------------------------------------------------------

****0 local deltas = {
         dev =    120000000,
         scm =    110000000,
         cvs =    100000000,
         rc =    -1000,
         pre =   -10000,
         beta =  -100000,
****0    alpha = -1000000
      }

****0 local version_mt = {
         --- Equality comparison for versions.
         -- All version numbers must be equal.
         -- If both versions have revision numbers, they must be equal;
         -- otherwise the revision number is ignored.
         -- @param v1 table: version table to compare.
         -- @param v2 table: version table to compare.
         -- @return boolean: true if they are considered equivalent.
         __eq = function(v1, v2)
****0       if #v1 ~= #v2 then
****0          return false
            end
****0       for i = 1, #v1 do
****0          if v1[i] ~= v2[i] then
****0             return false
               end
            end
****0       if v1.revision and v2.revision then
****0          return (v1.revision == v2.revision)
            end
****0       return true
         end,
         --- Size comparison for versions.
         -- All version numbers are compared.
         -- If both versions have revision numbers, they are compared;
         -- otherwise the revision number is ignored.
         -- @param v1 table: version table to compare.
         -- @param v2 table: version table to compare.
         -- @return boolean: true if v1 is considered lower than v2.
         __lt = function(v1, v2)
    4       for i = 1, math.max(#v1, #v2) do
    3          local v1i, v2i = v1[i] or 0, v2[i] or 0
    3          if v1i ~= v2i then
****0             return (v1i < v2i)
               end
            end
    1       if v1.revision and v2.revision then
    1          return (v1.revision < v2.revision)
            end
****0       return false
         end,
         -- @param v1 table: version table to compare.
         -- @param v2 table: version table to compare.
         -- @return boolean: true if v1 is considered lower than or equal to v2.
         __le = function(v1, v2)
****0        return not (v2 < v1)
         end,
         --- Return version as a string.
         -- @param v The version table.
         -- @return The string representation.
         __tostring = function(v)
****0       return v.string
         end,
      }

****0 local version_cache = {}
****0 setmetatable(version_cache, {
****0    __mode = "kv"
      })

      --- Parse a version string, converting to table format.
      -- A version table contains all components of the version string
      -- converted to numeric format, stored in the array part of the table.
      -- If the version contains a revision, it is stored numerically
      -- in the 'revision' field. The original string representation of
      -- the string is preserved in the 'string' field.
      -- Returned version tables use a metatable
      -- allowing later comparison through relational operators.
      -- @param vstring string: A version number in string format.
      -- @return table or nil: A version table or nil
      -- if the input string contains invalid characters.
****0 function vers.parse_version(vstring)
    2    if not vstring then return nil end
    2    assert(type(vstring) == "string")

    2    local cached = version_cache[vstring]
    2    if cached then
    1       return cached
         end

    1    local version = {}
    1    local i = 1

         local function add_token(number)
    3       version[i] = version[i] and version[i] + number/100000 or number
    3       i = i + 1
         end

         -- trim leading and trailing spaces
    1    local v = vstring:match("^%s*(.*)%s*$")
    1    version.string = v
         -- store revision separately if any
    1    local main, revision = v:match("(.*)%-(%d+)$")
    1    if revision then
    1       v = main
    1       version.revision = tonumber(revision)
         end
    4    while #v > 0 do
            -- extract a number
    3       local token, rest = v:match("^(%d+)[%.%-%_]*(.*)")
    3       if token then
    3          add_token(tonumber(token))
            else
               -- extract a word
****0          token, rest = v:match("^(%a+)[%.%-%_]*(.*)")
****0          if not token then
****0             util.warning("version number '"..v.."' could not be parsed.")
****0             version[i] = 0
                  break
               end
****0          version[i] = deltas[token] or (token:byte() / 1000)
            end
    3       v = rest
         end
    1    setmetatable(version, version_mt)
    1    version_cache[vstring] = version
    1    return version
      end

      --- Utility function to compare version numbers given as strings.
      -- @param a string: one version.
      -- @param b string: another version.
      -- @return boolean: True if a > b.
****0 function vers.compare_versions(a, b)
****0    if a == b then
****0       return false
         end
****0    return vers.parse_version(a) > vers.parse_version(b)
      end

      --- A more lenient check for equivalence between versions.
      -- This returns true if the requested components of a version
      -- match and ignore the ones that were not given. For example,
      -- when requesting "2", then "2", "2.1", "2.3.5-9"... all match.
      -- When requesting "2.1", then "2.1", "2.1.3" match, but "2.2"
      -- doesn't.
      -- @param version string or table: Version to be tested; may be
      -- in string format or already parsed into a table.
      -- @param requested string or table: Version requested; may be
      -- in string format or already parsed into a table.
      -- @return boolean: True if the tested version matches the requested
      -- version, false otherwise.
      local function partial_match(version, requested)
****0    assert(type(version) == "string" or type(version) == "table")
****0    assert(type(requested) == "string" or type(version) == "table")

****0    if type(version) ~= "table" then version = vers.parse_version(version) end
****0    if type(requested) ~= "table" then requested = vers.parse_version(requested) end
****0    if not version or not requested then return false end

****0    for i, ri in ipairs(requested) do
****0       local vi = version[i] or 0
****0       if ri ~= vi then return false end
         end
****0    if requested.revision then
****0       return requested.revision == version.revision
         end
****0    return true
      end

      --- Check if a version satisfies a set of constraints.
      -- @param version table: A version in table format
      -- @param constraints table: An array of constraints in table format.
      -- @return boolean: True if version satisfies all constraints,
      -- false otherwise.
****0 function vers.match_constraints(version, constraints)
****0    assert(type(version) == "table")
****0    assert(type(constraints) == "table")
****0    local ok = true
****0    setmetatable(version, version_mt)
****0    for _, constr in pairs(constraints) do
****0       if type(constr.version) == "string" then
****0          constr.version = vers.parse_version(constr.version)
            end
****0       local constr_version, constr_op = constr.version, constr.op
****0       setmetatable(constr_version, version_mt)
****0       if     constr_op == "==" then ok = version == constr_version
****0       elseif constr_op == "~=" then ok = version ~= constr_version
****0       elseif constr_op == ">"  then ok = version >  constr_version
****0       elseif constr_op == "<"  then ok = version <  constr_version
****0       elseif constr_op == ">=" then ok = version >= constr_version
****0       elseif constr_op == "<=" then ok = version <= constr_version
****0       elseif constr_op == "~>" then ok = partial_match(version, constr_version)
            end
****0       if not ok then break end
         end
****0    return ok
      end

****0 return vers

==============================================================================
/usr/share/lua/5.1/luarocks/loader.lua
==============================================================================
      --- A module which installs a Lua package loader that is LuaRocks-aware.
      -- This loader uses dependency information from the LuaRocks tree to load
      -- correct versions of modules. It does this by constructing a "context"
      -- table in the environment, which records which versions of packages were
      -- used to load previous modules, so that the loader chooses versions
      -- that are declared to be compatible with the ones loaded earlier.

      -- luacheck: globals luarocks

****0 local loaders = package.loaders or package.searchers
      local require, ipairs, table, type, next, tostring, error =
****0       require, ipairs, table, type, next, tostring, error
****0 local unpack = unpack or table.unpack

****0 local loader = {}

****0 local is_clean = not package.loaded["luarocks.core.cfg"]

      -- This loader module depends only on core modules.
****0 local cfg = require("luarocks.core.cfg")
****0 local cfg_ok, err = cfg.init()
****0 if cfg_ok then
****0    cfg.init_package_paths()
      end

****0 local path = require("luarocks.core.path")
****0 local manif = require("luarocks.core.manif")
****0 local vers = require("luarocks.core.vers")
      local require = nil  -- luacheck: ignore 411
      --------------------------------------------------------------------------------

      -- Workaround for wrappers produced by older versions of LuaRocks
****0 local temporary_global = false
****0 local status, luarocks_value = pcall(function() return luarocks end)
****0 if status and luarocks_value then
         -- The site_config.lua file generated by old versions uses module(),
         -- so it produces a global `luarocks` table. Since we have the table,
         -- add the `loader` field to make the old wrappers happy.
****0    luarocks.loader = loader
      else
         -- When a new version is installed on top of an old version,
         -- site_config.lua may be replaced, and then it no longer creates
         -- a global.
         -- Detect when being called via -lluarocks.loader; this is
         -- most likely a wrapper.
****0    local info = debug and debug.getinfo(2, "nS")
****0    if info and info.what == "C" and not info.name then
****0       luarocks = { loader = loader }
****0       temporary_global = true
            -- For the other half of this hack,
            -- see the next use of `temporary_global` below.
         end
      end

****0 loader.context = {}

      --- Process the dependencies of a package to determine its dependency
      -- chain for loading modules.
      -- @param name string: The name of an installed rock.
      -- @param version string: The version of the rock, in string format
****0 function loader.add_context(name, version)
         -- assert(type(name) == "string")
         -- assert(type(version) == "string")

   10    if temporary_global then
            -- The first thing a wrapper does is to call add_context.
            -- From here on, it's safe to clean the global environment.
****0       luarocks = nil
****0       temporary_global = false
         end

   10    local tree_manifests = manif.load_rocks_tree_manifests()
   10    if not tree_manifests then
****0       return nil
         end

   10    return manif.scan_dependencies(name, version, tree_manifests, loader.context)
      end

      --- Internal sorting function.
      -- @param a table: A provider table.
      -- @param b table: Another provider table.
      -- @return boolean: True if the version of a is greater than that of b.
      local function sort_versions(a,b)
    1    return a.version > b.version
      end

      --- Request module to be loaded through other loaders,
      -- once the proper name of the module has been determined.
      -- For example, in case the module "socket.core" has been requested
      -- to the LuaRocks loader and it determined based on context that
      -- the version 2.0.2 needs to be loaded and it is not the current
      -- version, the module requested for the other loaders will be
      -- "socket.core_2_0_2".
      -- @param module The module name requested by the user, such as "socket.core"
      -- @param name The rock name, such as "luasocket"
      -- @param version The rock version, such as "2.0.2-1"
      -- @param module_name The actual module name, such as "socket.core" or "socket.core_2_0_2".
      -- @return table or (nil, string): The module table as returned by some other loader,
      -- or nil followed by an error message if no other loader managed to load the module.
      local function call_other_loaders(module, name, version, module_name)
   30    for _, a_loader in ipairs(loaders) do
   30       if a_loader ~= loader.luarocks_loader then
   20          local results = { a_loader(module_name) }
   20          if type(results[1]) == "function" then
   10             return unpack(results)
               end
            end
         end
****0    return "Failed loading module "..module.." in LuaRocks rock "..name.." "..version
      end

      local function add_providers(providers, entries, tree, module, filter_file_name)
   13    for i, entry in ipairs(entries) do
   11       local name, version = entry:match("^([^/]*)/(.*)$")
   11       local file_name = tree.manifest.repository[name][version][1].modules[module]
   11       if type(file_name) ~= "string" then
****0          error("Invalid data in manifest file for module "..tostring(module).." (invalid data for "..tostring(name).." "..tostring(version)..")")
            end
   11       file_name = filter_file_name(file_name, name, version, tree.tree, i)
   11       if loader.context[name] == version then
    9          return name, version, file_name
            end
    2       version = vers.parse_version(version)
    2       table.insert(providers, {name = name, version = version, module_name = file_name, tree = tree})
         end
      end

      --- Search for a module in the rocks trees
      -- @param module string: module name (eg. "socket.core")
      -- @param filter_file_name function(string, string, string, string, number):
      -- a function that takes the module file name (eg "socket/core.so"), the rock name
      -- (eg "luasocket"), the version (eg "2.0.2-1"), the path of the rocks tree
      -- (eg "/usr/local"), and the numeric index of the matching entry, so the
      -- filter function can know if the matching module was the first entry or not.
      -- @return string, string, string, (string or table):
      -- * name of the rock containing the module (eg. "luasocket")
      -- * version of the rock (eg. "2.0.2-1")
      -- * return value of filter_file_name
      -- * tree of the module (string or table in `tree_manifests` format)
      local function select_module(module, filter_file_name)
         --assert(type(module) == "string")
         --assert(type(filter_module_name) == "function")

   13    local tree_manifests = manif.load_rocks_tree_manifests()
   13    if not tree_manifests then
****0       return nil
         end

   13    local providers = {}
         local initmodule
   21    for _, tree in ipairs(tree_manifests) do
   17       local entries = tree.manifest.modules[module]
   17       if entries then
   11          local n, v, f = add_providers(providers, entries, tree, module, filter_file_name)
   11          if n then
    9             return n, v, f
               end
            else
    6          initmodule = initmodule or module .. ".init"
    6          entries = tree.manifest.modules[initmodule]
    6          if entries then
****0             local n, v, f = add_providers(providers, entries, tree, initmodule, filter_file_name)
****0             if n then
****0                return n, v, f
                  end
               end
            end
         end

    4    if next(providers) then
    1       table.sort(providers, sort_versions)
    1       local first = providers[1]
    1       return first.name, first.version.string, first.module_name, first.tree
         end
      end

      --- Search for a module
      -- @param module string: module name (eg. "socket.core")
      -- @return string, string, string, (string or table):
      -- * name of the rock containing the module (eg. "luasocket")
      -- * version of the rock (eg. "2.0.2-1")
      -- * name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is stored versioned).
      -- * tree of the module (string or table in `tree_manifests` format)
      local function pick_module(module)
****0    return
   26       select_module(module, function(file_name, name, version, tree, i)
   11          if i > 1 then
****0             file_name = path.versioned_name(file_name, "", name, version)
               end
   11          return path.path_to_module(file_name)
            end)
      end

      --- Return the pathname of the file that would be loaded for a module.
      -- @param module string: module name (eg. "socket.core")
      -- @return filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so"),
      -- the rock name and the rock version.
****0 function loader.which(module)
****0    local rock_name, rock_version, file_name = select_module(module, path.which_i)
****0    return file_name, rock_name, rock_version
      end

      --- Package loader for LuaRocks support.
      -- A module is searched in installed rocks that match the
      -- current LuaRocks context. If module is not part of the
      -- context, or if a context has not yet been set, the module
      -- in the package with the highest version is used.
      -- @param module string: The module name, like in plain require().
      -- @return table: The module table (typically), like in plain
      -- require(). See <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
      -- in the Lua reference manual for details.
****0 function loader.luarocks_loader(module)
   13    local name, version, module_name = pick_module(module)
   13    if not name then
    3       return "No LuaRocks module found for "..module
         else
   10       loader.add_context(name, version)
   10       return call_other_loaders(module, name, version, module_name)
         end
      end

****0 table.insert(loaders, 1, loader.luarocks_loader)

****0 if is_clean then
****0    for modname, _ in pairs(package.loaded) do
****0       if modname:match("^luarocks%.") then
****0          package.loaded[modname] = nil
            end
         end
      end

****0 return loader

==============================================================================
cow/interpreter.lua
==============================================================================
    1 local CowInterpreter = {}
    1 CowInterpreter.__index = CowInterpreter

    1 local VALID_COMMANDS = {
    1     "MoO", "MOo", "moO", "mOo", "moo", "MOO", "OOM", "oom", "mOO", "Moo", "OOO", "MMM"
    1 }

    1 function CowInterpreter:new(code, input_str)
   18     local obj = {
   18         code = code,
   18         instructions = {},
   18         jump_map = {},
   18         memory = { [0] = 0 },
   18         mem_ptr = 0,
   18         instr_ptr = 1,
   18         register = nil,
   18         input = input_str or "",
   18         input_ptr = 1,
   18         output = ""
          }
   18     setmetatable(obj, self)
   18     return obj
      end

    1 function CowInterpreter:_parse_code()
  146     for word in self.code:gmatch("%S+") do
  468         for _, cmd in ipairs(VALID_COMMANDS) do
  455             if word == cmd then
  115                 table.insert(self.instructions, cmd)
  115                 break
                  end
              end
          end
      end

    1 function CowInterpreter:_build_jump_map()
   18     local stack = {}
  133     for i, instr in ipairs(self.instructions) do
  115         if instr == "moo" then
    6             table.insert(stack, i)
  109         elseif instr == "MOO" then
    5             if #stack > 0 then
    5                 local start_index = table.remove(stack)
    5                 self.jump_map[start_index] = i
    5                 self.jump_map[i] = start_index
                  end
              end
          end
      end

    1 function CowInterpreter:_get_mem()
  107     return self.memory[self.mem_ptr] or 0
      end

    1 function CowInterpreter:_set_mem(value)
   96     self.memory[self.mem_ptr] = value
      end

    1 function CowInterpreter:execute()
   17     self:_parse_code()
   17     self:_build_jump_map()

  129     while self.instr_ptr <= #self.instructions do
  112         local instr = self.instructions[self.instr_ptr]

  112         if instr == "MoO" then
   85             self:_set_mem(self:_get_mem() + 1)
   27         elseif instr == "MOo" then
    4             self:_set_mem(self:_get_mem() - 1)
   23         elseif instr == "moO" then
    2             self.mem_ptr = self.mem_ptr + 1
   21         elseif instr == "mOo" then
    1             self.mem_ptr = self.mem_ptr - 1
   20         elseif instr == "moo" then
    3             if self:_get_mem() == 0 then
    2                 self.instr_ptr = self.jump_map[self.instr_ptr] or self.instr_ptr
                  end
   17         elseif instr == "MOO" then
    3             if self.jump_map[self.instr_ptr] and self:_get_mem() ~= 0 then
    2                 self.instr_ptr = self.jump_map[self.instr_ptr]
                  end
   14         elseif instr == "OOM" then
    1             self.output = self.output .. tostring(self:_get_mem())
   13         elseif instr == "oom" then
    2             local num_str = self.input:sub(self.input_ptr):match("^-?%d+")
    2             if num_str then
    1                 self:_set_mem(tonumber(num_str))
    1                 self.input_ptr = self.input_ptr + #num_str
                  end
   11         elseif instr == "Moo" then
    5             if self:_get_mem() == 0 then
    3                 if self.input_ptr <= #self.input then
    2                     self:_set_mem(string.byte(self.input, self.input_ptr))
    2                     self.input_ptr = self.input_ptr + 1
                      end
                  else
    2                 local val = self:_get_mem()
    2                 if val >= 0 and val <= 255 then
    2                     self.output = self.output .. string.char(val)
                      end
                  end
    6         elseif instr == "OOO" then
    2             self:_set_mem(0)
    4         elseif instr == "MMM" then
    3             if self.register == nil then
    2                 self.register = self:_get_mem()
                  else
    1                 self:_set_mem(self.register)
    1                 self.register = nil
                  end
    1         elseif instr == "mOO" then
    1             local target_idx = self:_get_mem()
    1             if target_idx > 0 and target_idx <= #self.instructions then
    1                 local target_instr = self.instructions[target_idx]
                      -- Replicating logic for non-control-flow instructions
    1                 if target_instr == "MoO" then self:_set_mem(self:_get_mem() + 1)
****0                 elseif target_instr == "MOo" then self:_set_mem(self:_get_mem() - 1)
****0                 elseif target_instr == "moO" then self.mem_ptr = self.mem_ptr + 1
****0                 elseif target_instr == "mOo" then self.mem_ptr = self.mem_ptr - 1
****0                 elseif target_instr == "OOM" then self.output = self.output .. tostring(self:_get_mem())
****0                 elseif target_instr == "Moo" then
****0                     if self:_get_mem() == 0 then
****0                         if self.input_ptr <= #self.input then
****0                             self:_set_mem(string.byte(self.input, self.input_ptr))
****0                             self.input_ptr = self.input_ptr + 1
                              end
                          else
****0                         local val = self:_get_mem()
****0                         if val >= 0 and val <= 255 then self.output = self.output .. string.char(val) end
                          end
****0                 elseif target_instr == "OOO" then self:_set_mem(0)
****0                 elseif target_instr == "MMM" then
****0                     if self.register == nil then self.register = self:_get_mem()
****0                     else self:_set_mem(self.register); self.register = nil end
                      end
                  end
              end
  112         self.instr_ptr = self.instr_ptr + 1
          end

   17     return self.output
      end


    1 return CowInterpreter

==============================================================================
cow/tests/interpreter_spec.lua
==============================================================================
    1 local inspect = require('inspect') -- A library to pretty print tables, for debugging
    1 local CowInterpreter = require('cow.interpreter')

      local function read_file(path)
    1     local file = io.open(path, "rb") -- Open in binary mode
    1     if not file then return nil end
    1     local content = file:read("*a")
    1     file:close()
    1     return content:gsub("\r\n", "\n")
      end

    2 describe("CowInterpreter", function()

    2     it("should build a jump map for loops", function()
    1         local code = "moo MOO moo moo MOO MOO"
    1         local interpreter = CowInterpreter:new(code)
    1         interpreter:_parse_code()
    1         interpreter:_build_jump_map()
    1         assert.are.same({[1]=2, [2]=1, [3]=6, [4]=5, [5]=4, [6]=3}, interpreter.jump_map)
          end)
          
    2     it("should handle mismatched moo gracefully", function()
    1         local code = "moo moo MOO"
    1         local interpreter = CowInterpreter:new(code)
    2         assert.is_true(pcall(function() interpreter:execute() end))
          end)

    2     describe("Instructions", function()
    2         it("MoO should increment memory cell", function()
    1             local interpreter = CowInterpreter:new("MoO MoO")
    1             interpreter:execute()
    1             assert.are.equal(2, interpreter.memory[0])
              end)

    2         it("MOo should decrement memory cell", function()
    1             local interpreter = CowInterpreter:new("MoO MoO MOo")
    1             interpreter:execute()
    1             assert.are.equal(1, interpreter.memory[0])
              end)

    2         it("moO should move memory pointer forward", function()
    1             local interpreter = CowInterpreter:new("moO MoO")
    1             interpreter:execute()
    1             assert.are.equal(1, interpreter.mem_ptr)
    1             assert.are.equal(1, interpreter.memory[1])
              end)

    2         it("mOo should move memory pointer backward", function()
    1             local interpreter = CowInterpreter:new("moO mOo MoO")
    1             interpreter:execute()
    1             assert.are.equal(0, interpreter.mem_ptr)
    1             assert.are.equal(1, interpreter.memory[0])
              end)

    2         it("OOO should zero the current cell", function()
    1             local interpreter = CowInterpreter:new("MoO MoO OOO")
    1             interpreter:execute()
    1             assert.are.equal(0, interpreter.memory[0])
              end)

    2         it("MMM should copy to/from register", function()
    1             local interpreter = CowInterpreter:new("MoO MoO MMM")
    1             interpreter:execute()
    1             assert.are.equal(2, interpreter.register)
    1             assert.are.equal(2, interpreter.memory[0])
                  
    1             local interpreter2 = CowInterpreter:new("MoO MoO MMM OOO MMM")
    1             interpreter2:execute()
    1             assert.are.equal(nil, interpreter2.register)
    1             assert.are.equal(2, interpreter2.memory[0])
              end)

    2         it("OOM should output value as number string", function()
    1             local interpreter = CowInterpreter:new("MoO MoO MoO OOM")
    1             local output = interpreter:execute()
    1             assert.are.equal("3", output)
              end)

    2         it("Moo should output value as character if not zero", function()
    1             local code = ("MoO "):rep(65) .. "Moo"
    1             local interpreter = CowInterpreter:new(code)
    1             local output = interpreter:execute()
    1             assert.are.equal("A", output)
              end)

    2         it("Moo should read character if cell is zero", function()
    1             local interpreter = CowInterpreter:new("Moo", "B")
    1             interpreter:execute()
    1             assert.are.equal(66, interpreter.memory[0]) -- ASCII for 'B'
              end)

    2         it("oom should read a number", function()
    1             local interpreter = CowInterpreter:new("oom", "123")
    1             interpreter:execute()
    1             assert.are.equal(123, interpreter.memory[0])
              end)

    2         it("oom should do nothing if input is not a number", function()
    1             local interpreter = CowInterpreter:new("oom", "abc")
    1             interpreter:execute()
    1             assert.are.equal(0, interpreter.memory[0]) -- Should remain at its initial value
              end)

    2         it("mOO should execute instruction", function()
                  -- Set cell 0 to 2, then mOO will execute 2nd instruction (MoO)
    1             local code = "MoO MoO mOO"
    1             local interpreter = CowInterpreter:new(code)
    1             interpreter:execute()
                  -- 1. MoO -> mem[0] = 1
                  -- 2. MoO -> mem[0] = 2
                  -- 3. mOO -> mem[0] is 2, executes instr 2 (MoO), mem[0] becomes 3
    1             assert.are.equal(3, interpreter.memory[0])
              end)

    2         it("Moo should do nothing if cell is 0 and input is empty", function()
    1             local interpreter = CowInterpreter:new("Moo", "")
    1             interpreter:execute()
    1             assert.are.equal(0, interpreter.memory[0]) -- Should remain at its initial value
              end)

    2         it("loops correctly", function()
    1             local code = "MoO MoO MoO moo MOo MOO"
    1             local interpreter = CowInterpreter:new(code)
    1             interpreter:execute()
    1             assert.are.equal(0, interpreter.memory[0])
              end)
          end)

    2     describe("Simple example file", function()
    2         it("should interpret echo.cow correctly", function()
    1             local code = read_file("cow/examples/echo.cow")
    1             assert.is_not_nil(code, "echo.cow not found")
    1             local interpreter = CowInterpreter:new(code, "A")
    1             local output = interpreter:execute()
    1             assert.are.equal("A", output)
              end)
          end)

    2     describe("Provided (broken) Example files", function()
    2         it("should interpret hello.cow correctly", function()
    1             pending("Provided hello.cow file is syntactically incorrect and produces wrong output")
****0             local code = read_file("cow/examples/hello.cow")
****0             assert.is_not_nil(code, "hello.cow not found")
****0             local interpreter = CowInterpreter:new(code)
****0             local output = interpreter:execute()
****0             assert.are.equal("Hello, World!\n", output)
              end)

    2         it("should interpret fib.cow correctly", function()
    1             pending("Provided fib.cow file is syntactically incorrect and produces wrong output")
****0             local code = read_file("cow/examples/fib.cow")
****0             assert.is_not_nil(code, "hello.cow not found")
****0             local interpreter = CowInterpreter:new(code)
****0             local output = interpreter:execute()
****0             assert.are.equal("1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...", output)
              end)
          end)
      end)

==============================================================================
Summary
==============================================================================

File                                                                          Hits Missed Coverage
--------------------------------------------------------------------------------------------------
/home/ubuntu/.luarocks/share/lua/5.1/busted/block.lua                         64   31     67.37%
/home/ubuntu/.luarocks/share/lua/5.1/busted/context.lua                       39   43     47.56%
/home/ubuntu/.luarocks/share/lua/5.1/busted/core.lua                          106  91     53.81%
/home/ubuntu/.luarocks/share/lua/5.1/busted/environment.lua                   6    15     28.57%
/home/ubuntu/.luarocks/share/lua/5.1/busted/execute.lua                       19   21     47.50%
/home/ubuntu/.luarocks/share/lua/5.1/busted/init.lua                          23   56     29.11%
/home/ubuntu/.luarocks/share/lua/5.1/busted/languages/en.lua                  38   0      100.00%
/home/ubuntu/.luarocks/share/lua/5.1/busted/luajit.lua                        3    25     10.71%
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/files/lua.lua             10   1      90.91%
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/files/moonscript.lua      6    46     11.54%
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/filter_loader.lua         35   48     42.17%
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/output_handler_loader.lua 9    10     47.37%
/home/ubuntu/.luarocks/share/lua/5.1/busted/modules/test_file_loader.lua      32   22     59.26%
/home/ubuntu/.luarocks/share/lua/5.1/busted/outputHandlers/base.lua           77   26     74.76%
/home/ubuntu/.luarocks/share/lua/5.1/busted/outputHandlers/plainTerminal.lua  75   40     65.22%
/home/ubuntu/.luarocks/share/lua/5.1/busted/runner.lua                        57   76     42.86%
/home/ubuntu/.luarocks/share/lua/5.1/busted/status.lua                        22   2      91.67%
/home/ubuntu/.luarocks/share/lua/5.1/busted/utils.lua                         13   8      61.90%
/home/ubuntu/.luarocks/share/lua/5.1/inspect.lua                              34   126    21.25%
/home/ubuntu/.luarocks/share/lua/5.1/luassert/assert.lua                      19   62     23.46%
/home/ubuntu/.luarocks/share/lua/5.1/luassert/assertions.lua                  29   191    13.18%
/home/ubuntu/.luarocks/share/lua/5.1/luassert/modifiers.lua                   3    8      27.27%
/home/ubuntu/.luarocks/share/lua/5.1/luassert/util.lua                        74   104    41.57%
/home/ubuntu/.luarocks/share/lua/5.1/mediator.lua                             41   26     61.19%
/home/ubuntu/.luarocks/share/lua/5.1/pl/dir.lua                               29   224    11.46%
/home/ubuntu/.luarocks/share/lua/5.1/pl/path.lua                              26   232    10.08%
/home/ubuntu/.luarocks/share/lua/5.1/pl/tablex.lua                            15   389    3.71%
/home/ubuntu/.luarocks/share/lua/5.1/pl/types.lua                             3    59     4.84%
/home/ubuntu/.luarocks/share/lua/5.1/pl/utils.lua                             4    297    1.33%
/home/ubuntu/.luarocks/share/lua/5.1/say/init.lua                             13   15     46.43%
/usr/share/lua/5.1/luarocks/core/dir.lua                                      31   13     70.45%
/usr/share/lua/5.1/luarocks/core/manif.lua                                    26   28     48.15%
/usr/share/lua/5.1/luarocks/core/path.lua                                     23   46     33.33%
/usr/share/lua/5.1/luarocks/core/vers.lua                                     28   61     31.46%
/usr/share/lua/5.1/luarocks/loader.lua                                        43   43     50.00%
cow/interpreter.lua                                                           88   15     85.44%
cow/tests/interpreter_spec.lua                                                97   10     90.65%
--------------------------------------------------------------------------------------------------
Total                                                                         1260 2510   33.42%
